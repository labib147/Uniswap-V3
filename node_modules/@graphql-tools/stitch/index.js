'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const graphql = require('graphql');
const utils = require('@graphql-tools/utils');
const schema = require('@graphql-tools/schema');
const delegate = require('@graphql-tools/delegate');
const wrap = require('@graphql-tools/wrap');
const merge = require('@graphql-tools/merge');
const batchDelegate = require('@graphql-tools/batch-delegate');
const valueOrPromise = require('value-or-promise');

const backcompatOptions = { commentDescriptions: true };
function typeFromAST(node) {
    switch (node.kind) {
        case graphql.Kind.OBJECT_TYPE_DEFINITION:
            return makeObjectType(node);
        case graphql.Kind.INTERFACE_TYPE_DEFINITION:
            return makeInterfaceType(node);
        case graphql.Kind.ENUM_TYPE_DEFINITION:
            return makeEnumType(node);
        case graphql.Kind.UNION_TYPE_DEFINITION:
            return makeUnionType(node);
        case graphql.Kind.SCALAR_TYPE_DEFINITION:
            return makeScalarType(node);
        case graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION:
            return makeInputObjectType(node);
        case graphql.Kind.DIRECTIVE_DEFINITION:
            return makeDirective(node);
        default:
            return null;
    }
}
function makeObjectType(node) {
    const config = {
        name: node.name.value,
        description: utils.getDescription(node, backcompatOptions),
        interfaces: () => { var _a; return ((_a = node.interfaces) === null || _a === void 0 ? void 0 : _a.map(iface => utils.createNamedStub(iface.name.value, 'interface'))) || []; },
        fields: () => (node.fields != null ? makeFields(node.fields) : {}),
        astNode: node,
    };
    return new graphql.GraphQLObjectType(config);
}
function makeInterfaceType(node) {
    const config = {
        name: node.name.value,
        description: utils.getDescription(node, backcompatOptions),
        interfaces: () => {
            var _a;
            return (_a = node.interfaces) === null || _a === void 0 ? void 0 : _a.map(iface => utils.createNamedStub(iface.name.value, 'interface'));
        },
        fields: () => (node.fields != null ? makeFields(node.fields) : {}),
        astNode: node,
    };
    return new graphql.GraphQLInterfaceType(config);
}
function makeEnumType(node) {
    var _a, _b;
    const values = (_b = (_a = node.values) === null || _a === void 0 ? void 0 : _a.reduce((prev, value) => ({
        ...prev,
        [value.name.value]: {
            description: utils.getDescription(value, backcompatOptions),
            deprecationReason: getDeprecationReason(value),
            astNode: value,
        },
    }), {})) !== null && _b !== void 0 ? _b : {};
    return new graphql.GraphQLEnumType({
        name: node.name.value,
        description: utils.getDescription(node, backcompatOptions),
        values,
        astNode: node,
    });
}
function makeUnionType(node) {
    return new graphql.GraphQLUnionType({
        name: node.name.value,
        description: utils.getDescription(node, backcompatOptions),
        types: () => { var _a, _b; return (_b = (_a = node.types) === null || _a === void 0 ? void 0 : _a.map(type => utils.createNamedStub(type.name.value, 'object'))) !== null && _b !== void 0 ? _b : []; },
        astNode: node,
    });
}
function makeScalarType(node) {
    return new graphql.GraphQLScalarType({
        name: node.name.value,
        description: utils.getDescription(node, backcompatOptions),
        astNode: node,
        // TODO: serialize default property setting can be dropped once
        // upstream graphql-js TypeScript typings are updated, likely in v16
        serialize: value => value,
    });
}
function makeInputObjectType(node) {
    return new graphql.GraphQLInputObjectType({
        name: node.name.value,
        description: utils.getDescription(node, backcompatOptions),
        fields: () => (node.fields ? makeValues(node.fields) : {}),
        astNode: node,
    });
}
function makeFields(nodes) {
    return nodes.reduce((prev, node) => {
        var _a;
        return ({
            ...prev,
            [node.name.value]: {
                type: utils.createStub(node.type, 'output'),
                description: utils.getDescription(node, backcompatOptions),
                args: makeValues((_a = node.arguments) !== null && _a !== void 0 ? _a : []),
                deprecationReason: getDeprecationReason(node),
                astNode: node,
            },
        });
    }, {});
}
function makeValues(nodes) {
    return nodes.reduce((prev, node) => ({
        ...prev,
        [node.name.value]: {
            type: utils.createStub(node.type, 'input'),
            defaultValue: node.defaultValue !== undefined ? graphql.valueFromASTUntyped(node.defaultValue) : undefined,
            description: utils.getDescription(node, backcompatOptions),
            astNode: node,
        },
    }), {});
}
function isLocationValue(value) {
    return value in graphql.DirectiveLocation;
}
function makeDirective(node) {
    var _a;
    const locations = [];
    for (const location of node.locations) {
        const locationValue = location.value;
        if (isLocationValue(locationValue)) {
            locations.push(locationValue);
        }
    }
    return new graphql.GraphQLDirective({
        name: node.name.value,
        description: node.description != null ? node.description.value : null,
        locations: locations,
        isRepeatable: node.repeatable,
        args: makeValues((_a = node.arguments) !== null && _a !== void 0 ? _a : []),
        astNode: node,
    });
}
function getDeprecationReason(node) {
    const deprecated = graphql.getDirectiveValues(graphql.GraphQLDeprecatedDirective, node);
    return deprecated === null || deprecated === void 0 ? void 0 : deprecated['reason'];
}

(function (ValidationLevel) {
    ValidationLevel["Error"] = "error";
    ValidationLevel["Warn"] = "warn";
    ValidationLevel["Off"] = "off";
})(exports.ValidationLevel || (exports.ValidationLevel = {}));

function validateFieldConsistency(finalFieldConfig, candidates, typeMergingOptions) {
    const fieldNamespace = `${candidates[0].type.name}.${candidates[0].fieldName}`;
    const finalFieldNull = graphql.isNonNullType(finalFieldConfig.type);
    validateTypeConsistency(finalFieldConfig, candidates.map(c => c.fieldConfig), 'field', fieldNamespace, typeMergingOptions);
    if (getValidationSettings(fieldNamespace, typeMergingOptions).strictNullComparison &&
        candidates.some(c => finalFieldNull !== graphql.isNonNullType(c.fieldConfig.type))) {
        validationMessage(`Nullability of field "${fieldNamespace}" does not match across subschemas. Disable typeMergingOptions.validationSettings.strictNullComparison to permit safe divergences.`, fieldNamespace, typeMergingOptions);
    }
    else if (finalFieldNull && candidates.some(c => !graphql.isNonNullType(c.fieldConfig.type))) {
        validationMessage(`Canonical definition of field "${fieldNamespace}" is not-null while some subschemas permit null. This will be an automatic error in future versions.`, fieldNamespace, typeMergingOptions);
    }
    const argCandidatesMap = Object.create(null);
    for (const { fieldConfig } of candidates) {
        if (fieldConfig.args == null) {
            continue;
        }
        for (const argName in fieldConfig.args) {
            const arg = fieldConfig.args[argName];
            argCandidatesMap[argName] = argCandidatesMap[argName] || [];
            argCandidatesMap[argName].push(arg);
        }
    }
    if (Object.values(argCandidatesMap).some(argCandidates => candidates.length !== argCandidates.length)) {
        validationMessage(`Canonical definition of field "${fieldNamespace}" implements inconsistent argument names across subschemas. Input may be filtered from some requests.`, fieldNamespace, typeMergingOptions);
    }
    for (const argName in argCandidatesMap) {
        if (finalFieldConfig.args == null) {
            continue;
        }
        const argCandidates = argCandidatesMap[argName];
        const argNamespace = `${fieldNamespace}.${argName}`;
        const finalArgConfig = finalFieldConfig.args[argName] || argCandidates[argCandidates.length - 1];
        const finalArgType = graphql.getNamedType(finalArgConfig.type);
        const finalArgNull = graphql.isNonNullType(finalArgConfig.type);
        validateTypeConsistency(finalArgConfig, argCandidates, 'argument', argNamespace, typeMergingOptions);
        if (getValidationSettings(argNamespace, typeMergingOptions).strictNullComparison &&
            argCandidates.some(c => finalArgNull !== graphql.isNonNullType(c.type))) {
            validationMessage(`Nullability of argument "${argNamespace}" does not match across subschemas. Disable typeMergingOptions.validationSettings.strictNullComparison to permit safe divergences.`, argNamespace, typeMergingOptions);
        }
        else if (!finalArgNull && argCandidates.some(c => graphql.isNonNullType(c.type))) {
            validationMessage(`Canonical definition of argument "${argNamespace}" permits null while some subschemas require not-null. This will be an automatic error in future versions.`, argNamespace, typeMergingOptions);
        }
        if (graphql.isEnumType(finalArgType)) {
            validateInputEnumConsistency(finalArgType, argCandidates, typeMergingOptions);
        }
    }
}
function validateInputObjectConsistency(fieldInclusionMap, candidates, typeMergingOptions) {
    for (const fieldName in fieldInclusionMap) {
        const count = fieldInclusionMap[fieldName];
        if (candidates.length !== count) {
            const namespace = `${candidates[0].type.name}.${fieldName}`;
            validationMessage(`Definition of input field "${namespace}" is not implemented by all subschemas. Input may be filtered from some requests.`, namespace, typeMergingOptions);
        }
    }
}
function validateInputFieldConsistency(finalInputFieldConfig, candidates, typeMergingOptions) {
    const inputFieldNamespace = `${candidates[0].type.name}.${candidates[0].fieldName}`;
    const inputFieldConfigs = candidates.map(c => c.inputFieldConfig);
    const finalInputFieldType = graphql.getNamedType(finalInputFieldConfig.type);
    const finalInputFieldNull = graphql.isNonNullType(finalInputFieldConfig.type);
    validateTypeConsistency(finalInputFieldConfig, inputFieldConfigs, 'input field', inputFieldNamespace, typeMergingOptions);
    if (getValidationSettings(inputFieldNamespace, typeMergingOptions).strictNullComparison &&
        candidates.some(c => finalInputFieldNull !== graphql.isNonNullType(c.inputFieldConfig.type))) {
        validationMessage(`Nullability of input field "${inputFieldNamespace}" does not match across subschemas. Disable typeMergingOptions.validationSettings.strictNullComparison to permit safe divergences.`, inputFieldNamespace, typeMergingOptions);
    }
    else if (!finalInputFieldNull && candidates.some(c => graphql.isNonNullType(c.inputFieldConfig.type))) {
        validationMessage(`Canonical definition of input field "${inputFieldNamespace}" permits null while some subschemas require not-null. This will be an automatic error in future versions.`, inputFieldNamespace, typeMergingOptions);
    }
    if (graphql.isEnumType(finalInputFieldType)) {
        validateInputEnumConsistency(finalInputFieldType, inputFieldConfigs, typeMergingOptions);
    }
}
function validateTypeConsistency(finalElementConfig, candidates, definitionType, settingNamespace, typeMergingOptions) {
    var _a, _b, _c;
    const finalNamedType = graphql.getNamedType(finalElementConfig.type);
    const finalIsScalar = graphql.isScalarType(finalNamedType);
    const finalIsList = hasListType(finalElementConfig.type);
    for (const c of candidates) {
        if (finalIsList !== hasListType(c.type)) {
            throw new Error(`Definitions of ${definitionType} "${settingNamespace}" implement inconsistent list types across subschemas and cannot be merged.`);
        }
        const currentNamedType = graphql.getNamedType(c.type);
        if (finalNamedType.toString() !== currentNamedType.toString()) {
            const proxiableScalar = !!((_c = (_b = (_a = typeMergingOptions === null || typeMergingOptions === void 0 ? void 0 : typeMergingOptions.validationSettings) === null || _a === void 0 ? void 0 : _a.proxiableScalars) === null || _b === void 0 ? void 0 : _b[finalNamedType.toString()]) === null || _c === void 0 ? void 0 : _c.includes(currentNamedType.toString()));
            const bothScalars = finalIsScalar && graphql.isScalarType(currentNamedType);
            const permitScalar = proxiableScalar && bothScalars;
            if (proxiableScalar && !bothScalars) {
                throw new Error(`Types ${finalNamedType} and ${currentNamedType} are not proxiable scalars.`);
            }
            if (!permitScalar) {
                validationMessage(`Definitions of ${definitionType} "${settingNamespace}" implement inconsistent named types across subschemas. This will be an automatic error in future versions.`, settingNamespace, typeMergingOptions);
            }
        }
    }
}
function hasListType(type) {
    return graphql.isListType(graphql.getNullableType(type));
}
function validateInputEnumConsistency(inputEnumType, candidates, typeMergingOptions) {
    const enumValueInclusionMap = Object.create(null);
    for (const candidate of candidates) {
        const enumType = graphql.getNamedType(candidate.type);
        if (graphql.isEnumType(enumType)) {
            for (const { value } of enumType.getValues()) {
                enumValueInclusionMap[value] = enumValueInclusionMap[value] || 0;
                enumValueInclusionMap[value] += 1;
            }
        }
    }
    if (Object.values(enumValueInclusionMap).some(count => candidates.length !== count)) {
        validationMessage(`Enum "${inputEnumType.name}" is used as an input with inconsistent values across subschemas. This will be an automatic error in future versions.`, inputEnumType.name, typeMergingOptions);
    }
}
function validationMessage(message, settingNamespace, typeMergingOptions) {
    var _a;
    const override = `typeMergingOptions.validationScopes['${settingNamespace}'].validationLevel`;
    const settings = getValidationSettings(settingNamespace, typeMergingOptions);
    switch ((_a = settings.validationLevel) !== null && _a !== void 0 ? _a : exports.ValidationLevel.Warn) {
        case exports.ValidationLevel.Off:
            return;
        case exports.ValidationLevel.Error:
            throw new Error(`${message} If this is intentional, you may disable this error by setting ${override} = "warn|off"`);
        default:
            console.warn(`${message} To disable this warning or elevate it to an error, set ${override} = "error|off"`);
    }
}
function getValidationSettings(settingNamespace, typeMergingOptions) {
    var _a, _b, _c;
    return {
        ...((_a = typeMergingOptions === null || typeMergingOptions === void 0 ? void 0 : typeMergingOptions.validationSettings) !== null && _a !== void 0 ? _a : {}),
        ...((_c = (_b = typeMergingOptions === null || typeMergingOptions === void 0 ? void 0 : typeMergingOptions.validationScopes) === null || _b === void 0 ? void 0 : _b[settingNamespace]) !== null && _c !== void 0 ? _c : {}),
    };
}

function mergeCandidates(typeName, candidates, typeMergingOptions) {
    const initialCandidateType = candidates[0].type;
    if (candidates.some(candidate => candidate.type.constructor !== initialCandidateType.constructor)) {
        throw new Error(`Cannot merge different type categories into common type ${typeName}.`);
    }
    if (graphql.isObjectType(initialCandidateType)) {
        return mergeObjectTypeCandidates(typeName, candidates, typeMergingOptions);
    }
    else if (graphql.isInputObjectType(initialCandidateType)) {
        return mergeInputObjectTypeCandidates(typeName, candidates, typeMergingOptions);
    }
    else if (graphql.isInterfaceType(initialCandidateType)) {
        return mergeInterfaceTypeCandidates(typeName, candidates, typeMergingOptions);
    }
    else if (graphql.isUnionType(initialCandidateType)) {
        return mergeUnionTypeCandidates(typeName, candidates, typeMergingOptions);
    }
    else if (graphql.isEnumType(initialCandidateType)) {
        return mergeEnumTypeCandidates(typeName, candidates, typeMergingOptions);
    }
    else if (graphql.isScalarType(initialCandidateType)) {
        return mergeScalarTypeCandidates(typeName, candidates, typeMergingOptions);
    }
    else {
        // not reachable.
        throw new Error(`Type ${typeName} has unknown GraphQL type.`);
    }
}
function mergeObjectTypeCandidates(typeName, candidates, typeMergingOptions) {
    candidates = orderedTypeCandidates(candidates, typeMergingOptions);
    const description = mergeTypeDescriptions(candidates, typeMergingOptions);
    const fields = fieldConfigMapFromTypeCandidates(candidates, typeMergingOptions);
    const typeConfigs = candidates.map(candidate => candidate.type.toConfig());
    const interfaceMap = typeConfigs
        .map(typeConfig => typeConfig.interfaces)
        .reduce((acc, interfaces) => {
        if (interfaces != null) {
            for (const iface of interfaces) {
                acc[iface.name] = iface;
            }
        }
        return acc;
    }, Object.create(null));
    const interfaces = Object.values(interfaceMap);
    const astNodes = pluck('astNode', candidates);
    const fieldAstNodes = canonicalFieldNamesForType(candidates)
        .map(fieldName => { var _a; return (_a = fields[fieldName]) === null || _a === void 0 ? void 0 : _a.astNode; })
        .filter(n => n != null);
    if (astNodes.length > 1 && fieldAstNodes.length) {
        astNodes.push({
            ...astNodes[astNodes.length - 1],
            fields: JSON.parse(JSON.stringify(fieldAstNodes)),
        });
    }
    const astNode = astNodes
        .slice(1)
        .reduce((acc, astNode) => merge.mergeType(astNode, acc, { ignoreFieldConflicts: true }), astNodes[0]);
    const extensionASTNodes = pluck('extensionASTNodes', candidates);
    const extensions = Object.assign({}, ...pluck('extensions', candidates));
    const typeConfig = {
        name: typeName,
        description,
        fields,
        interfaces,
        astNode,
        extensionASTNodes,
        extensions,
    };
    return new graphql.GraphQLObjectType(typeConfig);
}
function mergeInputObjectTypeCandidates(typeName, candidates, typeMergingOptions) {
    candidates = orderedTypeCandidates(candidates, typeMergingOptions);
    const description = mergeTypeDescriptions(candidates, typeMergingOptions);
    const fields = inputFieldConfigMapFromTypeCandidates(candidates, typeMergingOptions);
    const astNodes = pluck('astNode', candidates);
    const fieldAstNodes = canonicalFieldNamesForType(candidates)
        .map(fieldName => { var _a; return (_a = fields[fieldName]) === null || _a === void 0 ? void 0 : _a.astNode; })
        .filter(n => n != null);
    if (astNodes.length > 1 && fieldAstNodes.length) {
        astNodes.push({
            ...astNodes[astNodes.length - 1],
            fields: JSON.parse(JSON.stringify(fieldAstNodes)),
        });
    }
    const astNode = astNodes.slice(1).reduce((acc, astNode) => merge.mergeInputType(astNode, acc, {
        ignoreFieldConflicts: true,
    }), astNodes[0]);
    const extensionASTNodes = pluck('extensionASTNodes', candidates);
    const extensions = Object.assign({}, ...pluck('extensions', candidates));
    const typeConfig = {
        name: typeName,
        description,
        fields,
        astNode,
        extensionASTNodes,
        extensions,
    };
    return new graphql.GraphQLInputObjectType(typeConfig);
}
function pluck(typeProperty, candidates) {
    return candidates.map(candidate => candidate.type[typeProperty]).filter(value => value != null);
}
function mergeInterfaceTypeCandidates(typeName, candidates, typeMergingOptions) {
    candidates = orderedTypeCandidates(candidates, typeMergingOptions);
    const description = mergeTypeDescriptions(candidates, typeMergingOptions);
    const fields = fieldConfigMapFromTypeCandidates(candidates, typeMergingOptions);
    const typeConfigs = candidates.map(candidate => candidate.type.toConfig());
    const interfaceMap = typeConfigs
        .map(typeConfig => ('interfaces' in typeConfig ? typeConfig.interfaces : []))
        .reduce((acc, interfaces) => {
        if (interfaces != null) {
            for (const iface of interfaces) {
                acc[iface.name] = iface;
            }
        }
        return acc;
    }, Object.create(null));
    const interfaces = Object.values(interfaceMap);
    const astNodes = pluck('astNode', candidates);
    const fieldAstNodes = canonicalFieldNamesForType(candidates)
        .map(fieldName => { var _a; return (_a = fields[fieldName]) === null || _a === void 0 ? void 0 : _a.astNode; })
        .filter(n => n != null);
    if (astNodes.length > 1 && fieldAstNodes.length) {
        astNodes.push({
            ...astNodes[astNodes.length - 1],
            fields: JSON.parse(JSON.stringify(fieldAstNodes)),
        });
    }
    const astNode = astNodes.slice(1).reduce((acc, astNode) => merge.mergeInterface(astNode, acc, {
        ignoreFieldConflicts: true,
    }), astNodes[0]);
    const extensionASTNodes = pluck('extensionASTNodes', candidates);
    const extensions = Object.assign({}, ...pluck('extensions', candidates));
    const typeConfig = {
        name: typeName,
        description,
        fields,
        interfaces,
        astNode,
        extensionASTNodes,
        extensions,
    };
    return new graphql.GraphQLInterfaceType(typeConfig);
}
function mergeUnionTypeCandidates(typeName, candidates, typeMergingOptions) {
    candidates = orderedTypeCandidates(candidates, typeMergingOptions);
    const description = mergeTypeDescriptions(candidates, typeMergingOptions);
    const typeConfigs = candidates.map(candidate => {
        if (!graphql.isUnionType(candidate.type)) {
            throw new Error(`Expected ${candidate.type} to be a union type!`);
        }
        return candidate.type.toConfig();
    });
    const typeMap = typeConfigs.reduce((acc, typeConfig) => {
        for (const type of typeConfig.types) {
            acc[type.name] = type;
        }
        return acc;
    }, Object.create(null));
    const types = Object.values(typeMap);
    const astNodes = pluck('astNode', candidates);
    const astNode = astNodes
        .slice(1)
        .reduce((acc, astNode) => merge.mergeUnion(astNode, acc), astNodes[0]);
    const extensionASTNodes = pluck('extensionASTNodes', candidates);
    const extensions = Object.assign({}, ...pluck('extensions', candidates));
    const typeConfig = {
        name: typeName,
        description,
        types,
        astNode,
        extensionASTNodes,
        extensions,
    };
    return new graphql.GraphQLUnionType(typeConfig);
}
function mergeEnumTypeCandidates(typeName, candidates, typeMergingOptions) {
    candidates = orderedTypeCandidates(candidates, typeMergingOptions);
    const description = mergeTypeDescriptions(candidates, typeMergingOptions);
    const values = enumValueConfigMapFromTypeCandidates(candidates, typeMergingOptions);
    const astNodes = pluck('astNode', candidates);
    const astNode = astNodes
        .slice(1)
        .reduce((acc, astNode) => merge.mergeEnum(astNode, acc, { consistentEnumMerge: true }), astNodes[0]);
    const extensionASTNodes = pluck('extensionASTNodes', candidates);
    const extensions = Object.assign({}, ...pluck('extensions', candidates));
    const typeConfig = {
        name: typeName,
        description,
        values,
        astNode,
        extensionASTNodes,
        extensions,
    };
    return new graphql.GraphQLEnumType(typeConfig);
}
function enumValueConfigMapFromTypeCandidates(candidates, typeMergingOptions) {
    var _a;
    const enumValueConfigCandidatesMap = Object.create(null);
    for (const candidate of candidates) {
        const valueMap = candidate.type.toConfig().values;
        for (const enumValue in valueMap) {
            const enumValueConfigCandidate = {
                enumValueConfig: valueMap[enumValue],
                enumValue,
                type: candidate.type,
                subschema: candidate.subschema,
                transformedSubschema: candidate.transformedSubschema,
            };
            if (enumValue in enumValueConfigCandidatesMap) {
                enumValueConfigCandidatesMap[enumValue].push(enumValueConfigCandidate);
            }
            else {
                enumValueConfigCandidatesMap[enumValue] = [enumValueConfigCandidate];
            }
        }
    }
    const enumValueConfigMap = Object.create(null);
    for (const enumValue in enumValueConfigCandidatesMap) {
        const enumValueConfigMerger = (_a = typeMergingOptions === null || typeMergingOptions === void 0 ? void 0 : typeMergingOptions.enumValueConfigMerger) !== null && _a !== void 0 ? _a : defaultEnumValueConfigMerger;
        enumValueConfigMap[enumValue] = enumValueConfigMerger(enumValueConfigCandidatesMap[enumValue]);
    }
    return enumValueConfigMap;
}
function defaultEnumValueConfigMerger(candidates) {
    const preferred = candidates.find(({ type, transformedSubschema }) => { var _a, _b; return delegate.isSubschemaConfig(transformedSubschema) && ((_b = (_a = transformedSubschema.merge) === null || _a === void 0 ? void 0 : _a[type.name]) === null || _b === void 0 ? void 0 : _b.canonical); });
    return (preferred || candidates[candidates.length - 1]).enumValueConfig;
}
function mergeScalarTypeCandidates(typeName, candidates, typeMergingOptions) {
    candidates = orderedTypeCandidates(candidates, typeMergingOptions);
    const description = mergeTypeDescriptions(candidates, typeMergingOptions);
    const serializeFns = pluck('serialize', candidates);
    const serialize = serializeFns[serializeFns.length - 1];
    const parseValueFns = pluck('parseValue', candidates);
    const parseValue = parseValueFns[parseValueFns.length - 1];
    const parseLiteralFns = pluck('parseLiteral', candidates);
    const parseLiteral = parseLiteralFns[parseLiteralFns.length - 1];
    const astNodes = pluck('astNode', candidates);
    const astNode = astNodes
        .slice(1)
        .reduce((acc, astNode) => merge.mergeScalar(astNode, acc), astNodes[0]);
    const extensionASTNodes = pluck('extensionASTNodes', candidates);
    const extensions = Object.assign({}, ...pluck('extensions', candidates));
    const typeConfig = {
        name: typeName,
        description,
        serialize,
        parseValue,
        parseLiteral,
        astNode,
        extensionASTNodes,
        extensions,
    };
    return new graphql.GraphQLScalarType(typeConfig);
}
function orderedTypeCandidates(candidates, typeMergingOptions) {
    var _a;
    const typeCandidateMerger = (_a = typeMergingOptions === null || typeMergingOptions === void 0 ? void 0 : typeMergingOptions.typeCandidateMerger) !== null && _a !== void 0 ? _a : defaultTypeCandidateMerger;
    const candidate = typeCandidateMerger(candidates);
    return candidates.filter(c => c !== candidate).concat([candidate]);
}
function defaultTypeCandidateMerger(candidates) {
    const canonical = candidates.filter(({ type, transformedSubschema }) => { var _a, _b; return delegate.isSubschemaConfig(transformedSubschema) ? (_b = (_a = transformedSubschema.merge) === null || _a === void 0 ? void 0 : _a[type.name]) === null || _b === void 0 ? void 0 : _b.canonical : false; });
    if (canonical.length > 1) {
        throw new Error(`Multiple canonical definitions for "${canonical[0].type.name}"`);
    }
    else if (canonical.length) {
        return canonical[0];
    }
    return candidates[candidates.length - 1];
}
function mergeTypeDescriptions(candidates, typeMergingOptions) {
    var _a;
    const typeDescriptionsMerger = (_a = typeMergingOptions === null || typeMergingOptions === void 0 ? void 0 : typeMergingOptions.typeDescriptionsMerger) !== null && _a !== void 0 ? _a : defaultTypeDescriptionMerger;
    return typeDescriptionsMerger(candidates);
}
function defaultTypeDescriptionMerger(candidates) {
    return candidates[candidates.length - 1].type.description;
}
function fieldConfigMapFromTypeCandidates(candidates, typeMergingOptions) {
    const fieldConfigCandidatesMap = Object.create(null);
    for (const candidate of candidates) {
        const typeConfig = candidate.type.toConfig();
        const fieldConfigMap = typeConfig.fields;
        for (const fieldName in fieldConfigMap) {
            const fieldConfig = fieldConfigMap[fieldName];
            const fieldConfigCandidate = {
                fieldConfig,
                fieldName,
                type: candidate.type,
                subschema: candidate.subschema,
                transformedSubschema: candidate.transformedSubschema,
            };
            if (fieldName in fieldConfigCandidatesMap) {
                fieldConfigCandidatesMap[fieldName].push(fieldConfigCandidate);
            }
            else {
                fieldConfigCandidatesMap[fieldName] = [fieldConfigCandidate];
            }
        }
    }
    const fieldConfigMap = Object.create(null);
    for (const fieldName in fieldConfigCandidatesMap) {
        fieldConfigMap[fieldName] = mergeFieldConfigs(fieldConfigCandidatesMap[fieldName], typeMergingOptions);
    }
    return fieldConfigMap;
}
function mergeFieldConfigs(candidates, typeMergingOptions) {
    var _a;
    const fieldConfigMerger = (_a = typeMergingOptions === null || typeMergingOptions === void 0 ? void 0 : typeMergingOptions.fieldConfigMerger) !== null && _a !== void 0 ? _a : defaultFieldConfigMerger;
    const finalFieldConfig = fieldConfigMerger(candidates);
    validateFieldConsistency(finalFieldConfig, candidates, typeMergingOptions);
    return finalFieldConfig;
}
function defaultFieldConfigMerger(candidates) {
    var _a, _b, _c, _d, _e, _f;
    const canonicalByField = [];
    const canonicalByType = [];
    for (const { type, fieldName, fieldConfig, transformedSubschema } of candidates) {
        if (!delegate.isSubschemaConfig(transformedSubschema))
            continue;
        if ((_d = (_c = (_b = (_a = transformedSubschema.merge) === null || _a === void 0 ? void 0 : _a[type.name]) === null || _b === void 0 ? void 0 : _b.fields) === null || _c === void 0 ? void 0 : _c[fieldName]) === null || _d === void 0 ? void 0 : _d.canonical) {
            canonicalByField.push(fieldConfig);
        }
        else if ((_f = (_e = transformedSubschema.merge) === null || _e === void 0 ? void 0 : _e[type.name]) === null || _f === void 0 ? void 0 : _f.canonical) {
            canonicalByType.push(fieldConfig);
        }
    }
    if (canonicalByField.length > 1) {
        throw new Error(`Multiple canonical definitions for "${candidates[0].type.name}.${candidates[0].fieldName}"`);
    }
    else if (canonicalByField.length) {
        return canonicalByField[0];
    }
    else if (canonicalByType.length) {
        return canonicalByType[0];
    }
    return candidates[candidates.length - 1].fieldConfig;
}
function inputFieldConfigMapFromTypeCandidates(candidates, typeMergingOptions) {
    var _a;
    const inputFieldConfigCandidatesMap = Object.create(null);
    const fieldInclusionMap = Object.create(null);
    for (const candidate of candidates) {
        const typeConfig = candidate.type.toConfig();
        const inputFieldConfigMap = typeConfig.fields;
        for (const fieldName in inputFieldConfigMap) {
            const inputFieldConfig = inputFieldConfigMap[fieldName];
            fieldInclusionMap[fieldName] = fieldInclusionMap[fieldName] || 0;
            fieldInclusionMap[fieldName] += 1;
            const inputFieldConfigCandidate = {
                inputFieldConfig,
                fieldName,
                type: candidate.type,
                subschema: candidate.subschema,
                transformedSubschema: candidate.transformedSubschema,
            };
            if (fieldName in inputFieldConfigCandidatesMap) {
                inputFieldConfigCandidatesMap[fieldName].push(inputFieldConfigCandidate);
            }
            else {
                inputFieldConfigCandidatesMap[fieldName] = [inputFieldConfigCandidate];
            }
        }
    }
    validateInputObjectConsistency(fieldInclusionMap, candidates, typeMergingOptions);
    const inputFieldConfigMap = Object.create(null);
    for (const fieldName in inputFieldConfigCandidatesMap) {
        const inputFieldConfigMerger = (_a = typeMergingOptions === null || typeMergingOptions === void 0 ? void 0 : typeMergingOptions.inputFieldConfigMerger) !== null && _a !== void 0 ? _a : defaultInputFieldConfigMerger;
        inputFieldConfigMap[fieldName] = inputFieldConfigMerger(inputFieldConfigCandidatesMap[fieldName]);
        validateInputFieldConsistency(inputFieldConfigMap[fieldName], inputFieldConfigCandidatesMap[fieldName], typeMergingOptions);
    }
    return inputFieldConfigMap;
}
function defaultInputFieldConfigMerger(candidates) {
    var _a, _b, _c, _d, _e, _f;
    const canonicalByField = [];
    const canonicalByType = [];
    for (const { type, fieldName, inputFieldConfig, transformedSubschema } of candidates) {
        if (!delegate.isSubschemaConfig(transformedSubschema))
            continue;
        if ((_d = (_c = (_b = (_a = transformedSubschema.merge) === null || _a === void 0 ? void 0 : _a[type.name]) === null || _b === void 0 ? void 0 : _b.fields) === null || _c === void 0 ? void 0 : _c[fieldName]) === null || _d === void 0 ? void 0 : _d.canonical) {
            canonicalByField.push(inputFieldConfig);
        }
        else if ((_f = (_e = transformedSubschema.merge) === null || _e === void 0 ? void 0 : _e[type.name]) === null || _f === void 0 ? void 0 : _f.canonical) {
            canonicalByType.push(inputFieldConfig);
        }
    }
    if (canonicalByField.length > 1) {
        throw new Error(`Multiple canonical definitions for "${candidates[0].type.name}.${candidates[0].fieldName}"`);
    }
    else if (canonicalByField.length) {
        return canonicalByField[0];
    }
    else if (canonicalByType.length) {
        return canonicalByType[0];
    }
    return candidates[candidates.length - 1].inputFieldConfig;
}
function canonicalFieldNamesForType(candidates) {
    var _a;
    const canonicalFieldNames = Object.create(null);
    for (const { type, transformedSubschema } of candidates) {
        if (!delegate.isSubschemaConfig(transformedSubschema))
            continue;
        const mergeConfig = (_a = transformedSubschema.merge) === null || _a === void 0 ? void 0 : _a[type.name];
        if (mergeConfig != null && mergeConfig.fields != null && !mergeConfig.canonical) {
            for (const fieldName in mergeConfig.fields) {
                const mergedFieldConfig = mergeConfig.fields[fieldName];
                if (mergedFieldConfig.canonical) {
                    canonicalFieldNames[fieldName] = true;
                }
            }
        }
    }
    return Object.keys(canonicalFieldNames);
}

function extractDefinitions(ast) {
    const typeDefinitions = [];
    const directiveDefs = [];
    const schemaDefs = [];
    const schemaExtensions = [];
    const extensionDefs = [];
    for (const def of ast.definitions) {
        switch (def.kind) {
            case graphql.Kind.OBJECT_TYPE_DEFINITION:
            case graphql.Kind.INTERFACE_TYPE_DEFINITION:
            case graphql.Kind.INPUT_OBJECT_TYPE_DEFINITION:
            case graphql.Kind.UNION_TYPE_DEFINITION:
            case graphql.Kind.ENUM_TYPE_DEFINITION:
            case graphql.Kind.SCALAR_TYPE_DEFINITION:
                typeDefinitions.push(def);
                break;
            case graphql.Kind.DIRECTIVE_DEFINITION:
                directiveDefs.push(def);
                break;
            case graphql.Kind.SCHEMA_DEFINITION:
                schemaDefs.push(def);
                break;
            case graphql.Kind.SCHEMA_EXTENSION:
                schemaExtensions.push(def);
                break;
            case graphql.Kind.OBJECT_TYPE_EXTENSION:
            case graphql.Kind.INTERFACE_TYPE_EXTENSION:
            case graphql.Kind.INPUT_OBJECT_TYPE_EXTENSION:
            case graphql.Kind.UNION_TYPE_EXTENSION:
            case graphql.Kind.ENUM_TYPE_EXTENSION:
            case graphql.Kind.SCALAR_TYPE_EXTENSION:
                extensionDefs.push(def);
                break;
        }
    }
    return {
        typeDefinitions,
        directiveDefs,
        schemaDefs,
        schemaExtensions,
        extensionDefs,
    };
}

function buildTypeCandidates({ subschemas, originalSubschemaMap, types, typeDefs, parseOptions, extensions, directiveMap, schemaDefs, mergeDirectives, }) {
    const typeCandidates = Object.create(null);
    let schemaDef;
    let schemaExtensions = [];
    let document;
    let extraction;
    if ((typeDefs && !Array.isArray(typeDefs)) || (Array.isArray(typeDefs) && typeDefs.length)) {
        document = merge.mergeTypeDefs(typeDefs, parseOptions);
        extraction = extractDefinitions(document);
        schemaDef = extraction.schemaDefs[0];
        schemaExtensions = schemaExtensions.concat(extraction.schemaExtensions);
    }
    schemaDefs.schemaDef = schemaDef !== null && schemaDef !== void 0 ? schemaDef : schemaDefs.schemaDef;
    schemaDefs.schemaExtensions = schemaExtensions;
    const rootTypeNameMap = getRootTypeNameMap(schemaDefs);
    for (const subschema of subschemas) {
        const schema = wrap.wrapSchema(subschema);
        const rootTypeMap = utils.getRootTypeMap(schema);
        const rootTypes = utils.getRootTypes(schema);
        for (const [operation, rootType] of rootTypeMap.entries()) {
            addTypeCandidate(typeCandidates, rootTypeNameMap[operation], {
                type: rootType,
                subschema: originalSubschemaMap.get(subschema),
                transformedSubschema: subschema,
            });
        }
        if (mergeDirectives === true) {
            for (const directive of schema.getDirectives()) {
                directiveMap[directive.name] = directive;
            }
        }
        const originalTypeMap = schema.getTypeMap();
        for (const typeName in originalTypeMap) {
            const type = originalTypeMap[typeName];
            if (graphql.isNamedType(type) &&
                graphql.getNamedType(type).name.slice(0, 2) !== '__' &&
                !rootTypes.has(type)) {
                addTypeCandidate(typeCandidates, type.name, {
                    type,
                    subschema: originalSubschemaMap.get(subschema),
                    transformedSubschema: subschema,
                });
            }
        }
    }
    if (document != null && extraction != null) {
        for (const def of extraction.typeDefinitions) {
            const type = typeFromAST(def);
            if (!graphql.isNamedType(type)) {
                throw new Error(`Expected to get named typed but got ${utils.inspect(def)}`);
            }
            if (type != null) {
                addTypeCandidate(typeCandidates, type.name, { type });
            }
        }
        for (const def of extraction.directiveDefs) {
            const directive = typeFromAST(def);
            if (!graphql.isDirective(directive)) {
                throw new Error(`Expected to get directive type but got ${utils.inspect(def)}`);
            }
            directiveMap[directive.name] = directive;
        }
        if (extraction.extensionDefs.length > 0) {
            extensions.push({
                ...document,
                definitions: extraction.extensionDefs,
            });
        }
    }
    for (const type of types) {
        addTypeCandidate(typeCandidates, type.name, { type });
    }
    return [typeCandidates, rootTypeNameMap];
}
function getRootTypeNameMap({ schemaDef, schemaExtensions, }) {
    const rootTypeNameMap = {
        query: 'Query',
        mutation: 'Mutation',
        subscription: 'Subscription',
    };
    const allNodes = schemaExtensions.slice();
    if (schemaDef != null) {
        allNodes.unshift(schemaDef);
    }
    for (const node of allNodes) {
        if (node.operationTypes != null) {
            for (const operationType of node.operationTypes) {
                rootTypeNameMap[operationType.operation] = operationType.type.name.value;
            }
        }
    }
    return rootTypeNameMap;
}
function addTypeCandidate(typeCandidates, name, typeCandidate) {
    if (!(name in typeCandidates)) {
        typeCandidates[name] = [];
    }
    typeCandidates[name].push(typeCandidate);
}
function buildTypes({ typeCandidates, directives, stitchingInfo, rootTypeNames, onTypeConflict, mergeTypes, typeMergingOptions, }) {
    const typeMap = Object.create(null);
    for (const typeName in typeCandidates) {
        if (rootTypeNames.includes(typeName) ||
            (mergeTypes === true && !typeCandidates[typeName].some(candidate => graphql.isSpecifiedScalarType(candidate.type))) ||
            (typeof mergeTypes === 'function' && mergeTypes(typeCandidates[typeName], typeName)) ||
            (Array.isArray(mergeTypes) && mergeTypes.includes(typeName)) ||
            (stitchingInfo != null && typeName in stitchingInfo.mergedTypes)) {
            typeMap[typeName] = mergeCandidates(typeName, typeCandidates[typeName], typeMergingOptions);
        }
        else {
            const candidateSelector = onTypeConflict != null
                ? onTypeConflictToCandidateSelector(onTypeConflict)
                : (cands) => cands[cands.length - 1];
            typeMap[typeName] = candidateSelector(typeCandidates[typeName]).type;
        }
    }
    return utils.rewireTypes(typeMap, directives);
}
function onTypeConflictToCandidateSelector(onTypeConflict) {
    return cands => cands.reduce((prev, next) => {
        const type = onTypeConflict(prev.type, next.type, {
            left: {
                subschema: prev.subschema,
                transformedSubschema: prev.transformedSubschema,
            },
            right: {
                subschema: next.subschema,
                transformedSubschema: next.transformedSubschema,
            },
        });
        if (prev.type === type) {
            return prev;
        }
        else if (next.type === type) {
            return next;
        }
        return {
            schemaName: 'unknown',
            type,
        };
    });
}

function createMergedTypeResolver(mergedTypeResolverOptions) {
    const { fieldName, argsFromKeys, valuesFromResults, args } = mergedTypeResolverOptions;
    if (argsFromKeys != null) {
        return function mergedBatchedTypeResolver(_originalResult, context, info, subschema, selectionSet, key, type = graphql.getNamedType(info.returnType)) {
            return batchDelegate.batchDelegateToSchema({
                schema: subschema,
                operation: 'query',
                fieldName,
                returnType: new graphql.GraphQLList(type),
                key,
                argsFromKeys,
                valuesFromResults,
                selectionSet,
                context,
                info,
                skipTypeMerging: true,
            });
        };
    }
    if (args != null) {
        return function mergedTypeResolver(originalResult, context, info, subschema, selectionSet, _key, type = graphql.getNamedType(info.returnType)) {
            return delegate.delegateToSchema({
                schema: subschema,
                operation: 'query',
                fieldName,
                returnType: type,
                args: args(originalResult),
                selectionSet,
                context,
                info,
                skipTypeMerging: true,
            });
        };
    }
    return undefined;
}

function getFieldsNotInSubschema(schema, stitchingInfo, gatewayType, subschemaType, fieldNodes, fragments, variableValues) {
    var _a;
    const subFieldNodesByResponseKey = utils.collectSubFields(schema, fragments, variableValues, gatewayType, fieldNodes);
    // TODO: Verify whether it is safe that extensions always exists.
    const fieldNodesByField = stitchingInfo === null || stitchingInfo === void 0 ? void 0 : stitchingInfo.fieldNodesByField;
    const fields = subschemaType.getFields();
    const fieldsNotInSchema = new Set();
    for (const [, subFieldNodes] of subFieldNodesByResponseKey) {
        const fieldName = subFieldNodes[0].name.value;
        if (!fields[fieldName]) {
            for (const subFieldNode of subFieldNodes) {
                fieldsNotInSchema.add(subFieldNode);
            }
        }
        const fieldNodesForField = (_a = fieldNodesByField === null || fieldNodesByField === void 0 ? void 0 : fieldNodesByField[gatewayType.name]) === null || _a === void 0 ? void 0 : _a[fieldName];
        if (fieldNodesForField) {
            for (const fieldNode of fieldNodesForField) {
                if (!fields[fieldNode.name.value]) {
                    fieldsNotInSchema.add(fieldNode);
                }
            }
        }
    }
    return Array.from(fieldsNotInSchema);
}

function calculateDelegationStage(mergedTypeInfo, sourceSubschemas, targetSubschemas, fieldNodes) {
    var _a;
    const { selectionSets, fieldSelectionSets, uniqueFields, nonUniqueFields } = mergedTypeInfo;
    // 1.  calculate if possible to delegate to given subschema
    const proxiableSubschemas = [];
    const nonProxiableSubschemas = [];
    for (const t of targetSubschemas) {
        const selectionSet = selectionSets.get(t);
        const fieldSelectionSetsMap = fieldSelectionSets.get(t);
        if (selectionSet != null && !subschemaTypesContainSelectionSet(mergedTypeInfo, sourceSubschemas, selectionSet)) {
            nonProxiableSubschemas.push(t);
        }
        else {
            if (fieldSelectionSetsMap == null ||
                fieldNodes.every(fieldNode => {
                    const fieldName = fieldNode.name.value;
                    const fieldSelectionSet = fieldSelectionSetsMap[fieldName];
                    return (fieldSelectionSet == null ||
                        subschemaTypesContainSelectionSet(mergedTypeInfo, sourceSubschemas, fieldSelectionSet));
                })) {
                proxiableSubschemas.push(t);
            }
            else {
                nonProxiableSubschemas.push(t);
            }
        }
    }
    const unproxiableFieldNodes = [];
    // 2. for each selection:
    const delegationMap = new Map();
    for (const fieldNode of fieldNodes) {
        if (fieldNode.name.value === '__typename') {
            continue;
        }
        // 2a. use uniqueFields map to assign fields to subschema if one of possible subschemas
        const uniqueSubschema = uniqueFields[fieldNode.name.value];
        if (uniqueSubschema != null) {
            if (!proxiableSubschemas.includes(uniqueSubschema)) {
                unproxiableFieldNodes.push(fieldNode);
                continue;
            }
            const existingSubschema = (_a = delegationMap.get(uniqueSubschema)) === null || _a === void 0 ? void 0 : _a.selections;
            if (existingSubschema != null) {
                existingSubschema.push(fieldNode);
            }
            else {
                delegationMap.set(uniqueSubschema, {
                    kind: graphql.Kind.SELECTION_SET,
                    selections: [fieldNode],
                });
            }
            continue;
        }
        // 2b. use nonUniqueFields to assign to a possible subschema,
        //     preferring one of the subschemas already targets of delegation
        let nonUniqueSubschemas = nonUniqueFields[fieldNode.name.value];
        if (nonUniqueSubschemas == null) {
            unproxiableFieldNodes.push(fieldNode);
            continue;
        }
        nonUniqueSubschemas = nonUniqueSubschemas.filter(s => proxiableSubschemas.includes(s));
        if (!nonUniqueSubschemas.length) {
            unproxiableFieldNodes.push(fieldNode);
            continue;
        }
        const existingSubschema = nonUniqueSubschemas.find(s => delegationMap.has(s));
        if (existingSubschema != null) {
            // It is okay we previously explicitly check whether the map has the element.
            delegationMap.get(existingSubschema).selections.push(fieldNode);
        }
        else {
            delegationMap.set(nonUniqueSubschemas[0], {
                kind: graphql.Kind.SELECTION_SET,
                selections: [fieldNode],
            });
        }
    }
    return {
        delegationMap,
        proxiableSubschemas,
        nonProxiableSubschemas,
        unproxiableFieldNodes,
    };
}
function getStitchingInfo(schema) {
    var _a;
    const stitchingInfo = (_a = schema.extensions) === null || _a === void 0 ? void 0 : _a['stitchingInfo'];
    if (!stitchingInfo) {
        throw new Error(`Schema is not a stitched schema.`);
    }
    return stitchingInfo;
}
function createDelegationPlanBuilder(mergedTypeInfo) {
    return utils.memoize5(function delegationPlanBuilder(schema, sourceSubschema, variableValues, fragments, fieldNodes) {
        var _a;
        const stitchingInfo = getStitchingInfo(schema);
        const targetSubschemas = mergedTypeInfo === null || mergedTypeInfo === void 0 ? void 0 : mergedTypeInfo.targetSubschemas.get(sourceSubschema);
        if (!targetSubschemas || !targetSubschemas.length) {
            return [];
        }
        const typeName = mergedTypeInfo.typeName;
        const fieldsNotInSubschema = getFieldsNotInSubschema(schema, stitchingInfo, schema.getType(typeName), (_a = mergedTypeInfo.typeMaps.get(sourceSubschema)) === null || _a === void 0 ? void 0 : _a[typeName], fieldNodes, fragments, variableValues);
        if (!fieldsNotInSubschema.length) {
            return [];
        }
        const delegationMaps = [];
        let sourceSubschemas = createSubschemas(sourceSubschema);
        let delegationStage = calculateDelegationStage(mergedTypeInfo, sourceSubschemas, targetSubschemas, fieldsNotInSubschema);
        let { delegationMap } = delegationStage;
        while (delegationMap.size) {
            delegationMaps.push(delegationMap);
            const { proxiableSubschemas, nonProxiableSubschemas, unproxiableFieldNodes } = delegationStage;
            sourceSubschemas = combineSubschemas(sourceSubschemas, proxiableSubschemas);
            delegationStage = calculateDelegationStage(mergedTypeInfo, sourceSubschemas, nonProxiableSubschemas, unproxiableFieldNodes);
            delegationMap = delegationStage.delegationMap;
        }
        return delegationMaps;
    });
}
const createSubschemas = utils.memoize1(function createSubschemas(sourceSubschema) {
    return [sourceSubschema];
});
const combineSubschemas = utils.memoize2(function combineSubschemas(sourceSubschemas, additionalSubschemas) {
    return sourceSubschemas.concat(additionalSubschemas);
});
const subschemaTypesContainSelectionSet = utils.memoize3(function subschemaTypesContainSelectionSet(mergedTypeInfo, sourceSubchemas, selectionSet) {
    return typesContainSelectionSet(sourceSubchemas.map(sourceSubschema => sourceSubschema.transformedSchema.getType(mergedTypeInfo.typeName)), selectionSet);
});
function typesContainSelectionSet(types, selectionSet) {
    var _a;
    const fieldMaps = types.map(type => type.getFields());
    for (const selection of selectionSet.selections) {
        if (selection.kind === graphql.Kind.FIELD) {
            const fields = fieldMaps.map(fieldMap => fieldMap[selection.name.value]).filter(field => field != null);
            if (!fields.length) {
                return false;
            }
            if (selection.selectionSet != null) {
                return typesContainSelectionSet(fields.map(field => graphql.getNamedType(field.type)), selection.selectionSet);
            }
        }
        else if (selection.kind === graphql.Kind.INLINE_FRAGMENT && ((_a = selection.typeCondition) === null || _a === void 0 ? void 0 : _a.name.value) === types[0].name) {
            return typesContainSelectionSet(types, selection.selectionSet);
        }
    }
    return true;
}

function createStitchingInfo(subschemaMap, typeCandidates, mergeTypes) {
    const mergedTypes = createMergedTypes(typeCandidates, mergeTypes);
    return {
        subschemaMap,
        fieldNodesByType: Object.create(null),
        fieldNodesByField: Object.create(null),
        dynamicSelectionSetsByField: Object.create(null),
        mergedTypes,
    };
}
function createMergedTypes(typeCandidates, mergeTypes) {
    var _a, _b;
    const mergedTypes = Object.create(null);
    for (const typeName in typeCandidates) {
        if (typeCandidates[typeName].length > 1 &&
            (graphql.isObjectType(typeCandidates[typeName][0].type) || graphql.isInterfaceType(typeCandidates[typeName][0].type))) {
            const typeCandidatesWithMergedTypeConfig = typeCandidates[typeName].filter(typeCandidate => typeCandidate.transformedSubschema != null &&
                typeCandidate.transformedSubschema.merge != null &&
                typeName in typeCandidate.transformedSubschema.merge);
            if (mergeTypes === true ||
                (typeof mergeTypes === 'function' && mergeTypes(typeCandidates[typeName], typeName)) ||
                (Array.isArray(mergeTypes) && mergeTypes.includes(typeName)) ||
                typeCandidatesWithMergedTypeConfig.length) {
                const targetSubschemas = [];
                const typeMaps = new Map();
                const supportedBySubschemas = Object.create({});
                const selectionSets = new Map();
                const fieldSelectionSets = new Map();
                const resolvers = new Map();
                for (const typeCandidate of typeCandidates[typeName]) {
                    const subschema = typeCandidate.transformedSubschema;
                    if (subschema == null) {
                        continue;
                    }
                    typeMaps.set(subschema, subschema.transformedSchema.getTypeMap());
                    const mergedTypeConfig = (_a = subschema === null || subschema === void 0 ? void 0 : subschema.merge) === null || _a === void 0 ? void 0 : _a[typeName];
                    if (mergedTypeConfig == null) {
                        continue;
                    }
                    if (mergedTypeConfig.selectionSet) {
                        const selectionSet = utils.parseSelectionSet(mergedTypeConfig.selectionSet, { noLocation: true });
                        selectionSets.set(subschema, selectionSet);
                    }
                    if (mergedTypeConfig.fields) {
                        const parsedFieldSelectionSets = Object.create(null);
                        for (const fieldName in mergedTypeConfig.fields) {
                            if (mergedTypeConfig.fields[fieldName].selectionSet) {
                                const rawFieldSelectionSet = mergedTypeConfig.fields[fieldName].selectionSet;
                                parsedFieldSelectionSets[fieldName] = rawFieldSelectionSet
                                    ? utils.parseSelectionSet(rawFieldSelectionSet, { noLocation: true })
                                    : undefined;
                            }
                        }
                        fieldSelectionSets.set(subschema, parsedFieldSelectionSets);
                    }
                    const resolver = (_b = mergedTypeConfig.resolve) !== null && _b !== void 0 ? _b : createMergedTypeResolver(mergedTypeConfig);
                    if (resolver == null) {
                        continue;
                    }
                    const keyFn = mergedTypeConfig.key;
                    resolvers.set(subschema, keyFn
                        ? function batchMergedTypeResolverWrapper(originalResult, context, info, subschema, selectionSet, type) {
                            return new valueOrPromise.ValueOrPromise(() => keyFn(originalResult))
                                .then(key => resolver(originalResult, context, info, subschema, selectionSet, key, type))
                                .resolve();
                        }
                        : resolver);
                    targetSubschemas.push(subschema);
                    const type = subschema.transformedSchema.getType(typeName);
                    const fieldMap = type.getFields();
                    const selectionSet = selectionSets.get(subschema);
                    for (const fieldName in fieldMap) {
                        const field = fieldMap[fieldName];
                        const fieldType = graphql.getNamedType(field.type);
                        if (selectionSet && graphql.isLeafType(fieldType) && selectionSetContainsTopLevelField(selectionSet, fieldName)) {
                            continue;
                        }
                        if (!(fieldName in supportedBySubschemas)) {
                            supportedBySubschemas[fieldName] = [];
                        }
                        supportedBySubschemas[fieldName].push(subschema);
                    }
                }
                const sourceSubschemas = typeCandidates[typeName]
                    .map(typeCandidate => typeCandidate === null || typeCandidate === void 0 ? void 0 : typeCandidate.transformedSubschema)
                    .filter(utils.isSome);
                const targetSubschemasBySubschema = new Map();
                for (const subschema of sourceSubschemas) {
                    const filteredSubschemas = targetSubschemas.filter(s => s !== subschema);
                    if (filteredSubschemas.length) {
                        targetSubschemasBySubschema.set(subschema, filteredSubschemas);
                    }
                }
                mergedTypes[typeName] = {
                    typeName,
                    targetSubschemas: targetSubschemasBySubschema,
                    typeMaps,
                    selectionSets,
                    fieldSelectionSets,
                    uniqueFields: Object.create({}),
                    nonUniqueFields: Object.create({}),
                    resolvers,
                };
                mergedTypes[typeName].delegationPlanBuilder = createDelegationPlanBuilder(mergedTypes[typeName]);
                for (const fieldName in supportedBySubschemas) {
                    if (supportedBySubschemas[fieldName].length === 1) {
                        mergedTypes[typeName].uniqueFields[fieldName] = supportedBySubschemas[fieldName][0];
                    }
                    else {
                        mergedTypes[typeName].nonUniqueFields[fieldName] = supportedBySubschemas[fieldName];
                    }
                }
            }
        }
    }
    return mergedTypes;
}
function completeStitchingInfo(stitchingInfo, resolvers, schema) {
    const { fieldNodesByType, fieldNodesByField, dynamicSelectionSetsByField, mergedTypes } = stitchingInfo;
    // must add __typename to query and mutation root types to handle type merging with nested root types
    // cannot add __typename to subscription root types, but they cannot be nested
    const rootTypes = [schema.getQueryType(), schema.getMutationType()];
    for (const rootType of rootTypes) {
        if (rootType) {
            fieldNodesByType[rootType.name] = [
                utils.parseSelectionSet('{ __typename }', { noLocation: true }).selections[0],
            ];
        }
    }
    const selectionSetsByField = Object.create(null);
    for (const typeName in mergedTypes) {
        const mergedTypeInfo = mergedTypes[typeName];
        if (mergedTypeInfo.selectionSets == null && mergedTypeInfo.fieldSelectionSets == null) {
            continue;
        }
        for (const [subschemaConfig, selectionSet] of mergedTypeInfo.selectionSets) {
            const schema = subschemaConfig.transformedSchema;
            const type = schema.getType(typeName);
            const fields = type.getFields();
            for (const fieldName in fields) {
                const field = fields[fieldName];
                const fieldType = graphql.getNamedType(field.type);
                if (selectionSet && graphql.isLeafType(fieldType) && selectionSetContainsTopLevelField(selectionSet, fieldName)) {
                    continue;
                }
                updateSelectionSetMap(selectionSetsByField, typeName, fieldName, selectionSet, true);
            }
        }
        for (const [, selectionSetFieldMap] of mergedTypeInfo.fieldSelectionSets) {
            for (const fieldName in selectionSetFieldMap) {
                const selectionSet = selectionSetFieldMap[fieldName];
                updateSelectionSetMap(selectionSetsByField, typeName, fieldName, selectionSet, true);
            }
        }
    }
    for (const typeName in resolvers) {
        const type = schema.getType(typeName);
        if (type === undefined || graphql.isLeafType(type) || graphql.isInputObjectType(type) || graphql.isUnionType(type)) {
            continue;
        }
        const resolver = resolvers[typeName];
        for (const fieldName in resolver) {
            const field = resolver[fieldName];
            if (typeof field.selectionSet === 'function') {
                if (!(typeName in dynamicSelectionSetsByField)) {
                    dynamicSelectionSetsByField[typeName] = Object.create(null);
                }
                if (!(fieldName in dynamicSelectionSetsByField[typeName])) {
                    dynamicSelectionSetsByField[typeName][fieldName] = [];
                }
                dynamicSelectionSetsByField[typeName][fieldName].push(field.selectionSet);
            }
            else if (field.selectionSet) {
                const selectionSet = utils.parseSelectionSet(field.selectionSet, { noLocation: true });
                updateSelectionSetMap(selectionSetsByField, typeName, fieldName, selectionSet);
            }
        }
    }
    const variableValues = Object.create(null);
    const fragments = Object.create(null);
    const fieldNodeMap = Object.create(null);
    for (const typeName in selectionSetsByField) {
        const type = schema.getType(typeName);
        for (const fieldName in selectionSetsByField[typeName]) {
            for (const selectionSet of selectionSetsByField[typeName][fieldName]) {
                const fieldNodesByResponseKey = utils.collectFields(schema, fragments, variableValues, type, selectionSet, new Map(), new Set());
                for (const [, fieldNodes] of fieldNodesByResponseKey) {
                    for (const fieldNode of fieldNodes) {
                        const key = graphql.print(fieldNode);
                        if (fieldNodeMap[key] == null) {
                            fieldNodeMap[key] = fieldNode;
                            updateArrayMap(fieldNodesByField, typeName, fieldName, fieldNode);
                        }
                        else {
                            updateArrayMap(fieldNodesByField, typeName, fieldName, fieldNodeMap[key]);
                        }
                    }
                }
            }
        }
    }
    return stitchingInfo;
}
function updateSelectionSetMap(map, typeName, fieldName, selectionSet, includeTypename) {
    if (includeTypename) {
        const typenameSelectionSet = utils.parseSelectionSet('{ __typename }', { noLocation: true });
        updateArrayMap(map, typeName, fieldName, selectionSet, typenameSelectionSet);
        return;
    }
    updateArrayMap(map, typeName, fieldName, selectionSet);
}
function updateArrayMap(map, typeName, fieldName, value, initialValue) {
    if (map[typeName] == null) {
        const initialItems = initialValue === undefined ? [value] : [initialValue, value];
        map[typeName] = {
            [fieldName]: initialItems,
        };
    }
    else if (map[typeName][fieldName] == null) {
        const initialItems = initialValue === undefined ? [value] : [initialValue, value];
        map[typeName][fieldName] = initialItems;
    }
    else {
        map[typeName][fieldName].push(value);
    }
}
function addStitchingInfo(stitchedSchema, stitchingInfo) {
    return new graphql.GraphQLSchema({
        ...stitchedSchema.toConfig(),
        extensions: {
            ...stitchedSchema.extensions,
            stitchingInfo,
        },
    });
}
function selectionSetContainsTopLevelField(selectionSet, fieldName) {
    return selectionSet.selections.some(selection => selection.kind === graphql.Kind.FIELD && selection.name.value === fieldName);
}

function computedDirectiveTransformer(computedDirectiveName) {
    return (subschemaConfig) => {
        const newSubschemaConfig = delegate.cloneSubschemaConfig(subschemaConfig);
        utils.mapSchema(subschemaConfig.schema, {
            [utils.MapperKind.OBJECT_FIELD]: (fieldConfig, fieldName, typeName, schema) => {
                var _a, _b, _c, _d, _e;
                const mergeTypeConfig = (_a = newSubschemaConfig.merge) === null || _a === void 0 ? void 0 : _a[typeName];
                if (mergeTypeConfig == null) {
                    return undefined;
                }
                const computed = (_b = utils.getDirective(schema, fieldConfig, computedDirectiveName)) === null || _b === void 0 ? void 0 : _b[0];
                if (computed == null) {
                    return undefined;
                }
                const selectionSet = computed['fields'] != null ? `{ ${computed['fields']} }` : computed['selectionSet'];
                if (selectionSet == null) {
                    return undefined;
                }
                mergeTypeConfig.fields = (_c = mergeTypeConfig.fields) !== null && _c !== void 0 ? _c : {};
                mergeTypeConfig.fields[fieldName] = (_d = mergeTypeConfig.fields[fieldName]) !== null && _d !== void 0 ? _d : {};
                const mergeFieldConfig = mergeTypeConfig.fields[fieldName];
                mergeFieldConfig.selectionSet = (_e = mergeFieldConfig.selectionSet) !== null && _e !== void 0 ? _e : selectionSet;
                mergeFieldConfig.computed = true;
                return undefined;
            },
        });
        return newSubschemaConfig;
    };
}

function isolateComputedFieldsTransformer(subschemaConfig) {
    var _a, _b;
    if (subschemaConfig.merge == null) {
        return [subschemaConfig];
    }
    const baseSchemaTypes = Object.create(null);
    const isolatedSchemaTypes = Object.create(null);
    for (const typeName in subschemaConfig.merge) {
        const mergedTypeConfig = subschemaConfig.merge[typeName];
        baseSchemaTypes[typeName] = mergedTypeConfig;
        if (mergedTypeConfig.computedFields) {
            const mergeConfigFields = (_a = mergedTypeConfig.fields) !== null && _a !== void 0 ? _a : Object.create(null);
            for (const fieldName in mergedTypeConfig.computedFields) {
                const mergedFieldConfig = mergedTypeConfig.computedFields[fieldName];
                console.warn(`The "computedFields" setting is deprecated. Update your @graphql-tools/stitching-directives package, and/or update static merged type config to "${typeName}.fields.${fieldName} = { selectionSet: '${mergedFieldConfig.selectionSet}', computed: true }"`);
                mergeConfigFields[fieldName] = {
                    ...((_b = mergeConfigFields[fieldName]) !== null && _b !== void 0 ? _b : {}),
                    ...mergedFieldConfig,
                    computed: true,
                };
            }
            delete mergedTypeConfig.computedFields;
            mergedTypeConfig.fields = mergeConfigFields;
        }
        if (mergedTypeConfig.fields) {
            const baseFields = Object.create(null);
            const isolatedFields = Object.create(null);
            for (const fieldName in mergedTypeConfig.fields) {
                const mergedFieldConfig = mergedTypeConfig.fields[fieldName];
                if (mergedFieldConfig.computed && mergedFieldConfig.selectionSet) {
                    isolatedFields[fieldName] = mergedFieldConfig;
                }
                else if (mergedFieldConfig.computed) {
                    throw new Error(`A selectionSet is required for computed field "${typeName}.${fieldName}"`);
                }
                else {
                    baseFields[fieldName] = mergedFieldConfig;
                }
            }
            const isolatedFieldCount = Object.keys(isolatedFields).length;
            const objectType = subschemaConfig.schema.getType(typeName);
            if (isolatedFieldCount && isolatedFieldCount !== Object.keys(objectType.getFields()).length) {
                baseSchemaTypes[typeName] = {
                    ...mergedTypeConfig,
                    fields: baseFields,
                };
                isolatedSchemaTypes[typeName] = {
                    ...mergedTypeConfig,
                    fields: isolatedFields,
                    canonical: undefined,
                };
            }
        }
    }
    if (Object.keys(isolatedSchemaTypes).length) {
        return [
            filterBaseSubschema({ ...subschemaConfig, merge: baseSchemaTypes }, isolatedSchemaTypes),
            filterIsolatedSubschema({ ...subschemaConfig, merge: isolatedSchemaTypes }),
        ];
    }
    return [subschemaConfig];
}
function filterBaseSubschema(subschemaConfig, isolatedSchemaTypes) {
    var _a;
    const schema = subschemaConfig.schema;
    const typesForInterface = {};
    const filteredSchema = utils.pruneSchema(utils.filterSchema({
        schema,
        objectFieldFilter: (typeName, fieldName) => { var _a, _b; return !((_b = (_a = isolatedSchemaTypes[typeName]) === null || _a === void 0 ? void 0 : _a.fields) === null || _b === void 0 ? void 0 : _b[fieldName]); },
        interfaceFieldFilter: (typeName, fieldName) => {
            if (!typesForInterface[typeName]) {
                typesForInterface[typeName] = utils.getImplementingTypes(typeName, schema);
            }
            return !typesForInterface[typeName].some(implementingTypeName => { var _a, _b; return (_b = (_a = isolatedSchemaTypes[implementingTypeName]) === null || _a === void 0 ? void 0 : _a.fields) === null || _b === void 0 ? void 0 : _b[fieldName]; });
        },
    }));
    const filteredFields = {};
    for (const typeName in filteredSchema.getTypeMap()) {
        const type = filteredSchema.getType(typeName);
        if (graphql.isObjectType(type) || graphql.isInterfaceType(type)) {
            filteredFields[typeName] = { __typename: true };
            const fieldMap = type.getFields();
            for (const fieldName in fieldMap) {
                filteredFields[typeName][fieldName] = true;
            }
        }
    }
    const filteredSubschema = {
        ...subschemaConfig,
        merge: subschemaConfig.merge
            ? {
                ...subschemaConfig.merge,
            }
            : undefined,
        transforms: ((_a = subschemaConfig.transforms) !== null && _a !== void 0 ? _a : []).concat([
            new wrap.TransformCompositeFields((typeName, fieldName) => { var _a; return (((_a = filteredFields[typeName]) === null || _a === void 0 ? void 0 : _a[fieldName]) ? undefined : null); }, (typeName, fieldName) => { var _a; return (((_a = filteredFields[typeName]) === null || _a === void 0 ? void 0 : _a[fieldName]) ? undefined : null); }),
        ]),
    };
    const remainingTypes = filteredSchema.getTypeMap();
    const mergeConfig = filteredSubschema.merge;
    if (mergeConfig) {
        for (const mergeType in mergeConfig) {
            if (!remainingTypes[mergeType]) {
                delete mergeConfig[mergeType];
            }
        }
        if (!Object.keys(mergeConfig).length) {
            delete filteredSubschema.merge;
        }
    }
    return filteredSubschema;
}
function filterIsolatedSubschema(subschemaConfig) {
    var _a, _b, _c;
    const rootFields = {};
    for (const typeName in subschemaConfig.merge) {
        const mergedTypeConfig = subschemaConfig.merge[typeName];
        const entryPoints = (_a = mergedTypeConfig.entryPoints) !== null && _a !== void 0 ? _a : [mergedTypeConfig];
        for (const entryPoint of entryPoints) {
            if (entryPoint.fieldName != null) {
                rootFields[entryPoint.fieldName] = true;
            }
        }
    }
    const interfaceFields = {};
    for (const typeName in subschemaConfig.merge) {
        const type = subschemaConfig.schema.getType(typeName);
        if (!type || !('getInterfaces' in type)) {
            throw new Error(`${typeName} expected to have 'getInterfaces' method`);
        }
        for (const int of type.getInterfaces()) {
            const intType = subschemaConfig.schema.getType(int.name);
            if (!intType || !('getFields' in intType)) {
                throw new Error(`${int.name} expected to have 'getFields' method`);
            }
            for (const intFieldName in intType.getFields()) {
                if ((_b = subschemaConfig.merge[typeName].fields) === null || _b === void 0 ? void 0 : _b[intFieldName]) {
                    interfaceFields[int.name] = interfaceFields[int.name] || {};
                    interfaceFields[int.name][intFieldName] = true;
                }
            }
        }
    }
    const filteredSchema = utils.pruneSchema(utils.filterSchema({
        schema: subschemaConfig.schema,
        rootFieldFilter: (operation, fieldName) => operation === 'Query' && rootFields[fieldName] != null,
        objectFieldFilter: (typeName, fieldName) => { var _a, _b; return ((_b = (_a = subschemaConfig.merge[typeName]) === null || _a === void 0 ? void 0 : _a.fields) === null || _b === void 0 ? void 0 : _b[fieldName]) != null; },
        interfaceFieldFilter: (typeName, fieldName) => { var _a; return ((_a = interfaceFields[typeName]) === null || _a === void 0 ? void 0 : _a[fieldName]) != null; },
    }));
    const filteredFields = {};
    for (const typeName in filteredSchema.getTypeMap()) {
        const type = filteredSchema.getType(typeName);
        if (graphql.isObjectType(type) || graphql.isInterfaceType(type)) {
            filteredFields[typeName] = { __typename: true };
            const fieldMap = type.getFields();
            for (const fieldName in fieldMap) {
                filteredFields[typeName][fieldName] = true;
            }
        }
    }
    return {
        ...subschemaConfig,
        transforms: ((_c = subschemaConfig.transforms) !== null && _c !== void 0 ? _c : []).concat([
            new wrap.TransformCompositeFields((typeName, fieldName) => { var _a; return (((_a = filteredFields[typeName]) === null || _a === void 0 ? void 0 : _a[fieldName]) ? undefined : null); }, (typeName, fieldName) => { var _a; return (((_a = filteredFields[typeName]) === null || _a === void 0 ? void 0 : _a[fieldName]) ? undefined : null); }),
        ]),
    };
}

function splitMergedTypeEntryPointsTransformer(subschemaConfig) {
    var _a, _b, _c, _d;
    if (!subschemaConfig.merge)
        return [subschemaConfig];
    const maxEntryPoints = Object.values(subschemaConfig.merge).reduce((max, mergedTypeConfig) => {
        var _a, _b;
        return Math.max(max, (_b = (_a = mergedTypeConfig === null || mergedTypeConfig === void 0 ? void 0 : mergedTypeConfig.entryPoints) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);
    }, 0);
    if (maxEntryPoints === 0)
        return [subschemaConfig];
    const subschemaPermutations = [];
    for (let i = 0; i < maxEntryPoints; i += 1) {
        const subschemaPermutation = delegate.cloneSubschemaConfig(subschemaConfig);
        const mergedTypesCopy = (_a = subschemaPermutation.merge) !== null && _a !== void 0 ? _a : Object.create(null);
        let currentMerge = mergedTypesCopy;
        if (i > 0) {
            subschemaPermutation.merge = currentMerge = Object.create(null);
        }
        for (const typeName in mergedTypesCopy) {
            const mergedTypeConfig = mergedTypesCopy[typeName];
            const mergedTypeEntryPoint = (_b = mergedTypeConfig === null || mergedTypeConfig === void 0 ? void 0 : mergedTypeConfig.entryPoints) === null || _b === void 0 ? void 0 : _b[i];
            if (mergedTypeEntryPoint) {
                if ((_d = (_c = mergedTypeConfig.selectionSet) !== null && _c !== void 0 ? _c : mergedTypeConfig.fieldName) !== null && _d !== void 0 ? _d : mergedTypeConfig.resolve) {
                    throw new Error(`Merged type ${typeName} may not define entryPoints in addition to selectionSet, fieldName, or resolve`);
                }
                Object.assign(mergedTypeConfig, mergedTypeEntryPoint);
                delete mergedTypeConfig.entryPoints;
                if (i > 0) {
                    delete mergedTypeConfig.canonical;
                    if (mergedTypeConfig.fields != null) {
                        for (const mergedFieldName in mergedTypeConfig.fields) {
                            const mergedFieldConfig = mergedTypeConfig.fields[mergedFieldName];
                            delete mergedFieldConfig.canonical;
                        }
                    }
                }
                currentMerge[typeName] = mergedTypeConfig;
            }
        }
        subschemaPermutations.push(subschemaPermutation);
    }
    return subschemaPermutations;
}

const defaultSubschemaConfigTransforms = [
    computedDirectiveTransformer('computed'),
];

function stitchSchemas({ subschemas = [], types = [], typeDefs, onTypeConflict, mergeDirectives, mergeTypes = true, typeMergingOptions, subschemaConfigTransforms = defaultSubschemaConfigTransforms, resolvers = {}, inheritResolversFromInterfaces = false, resolverValidationOptions = {}, parseOptions = {}, pruningOptions, updateResolversInPlace, schemaExtensions, }) {
    if (typeof resolverValidationOptions !== 'object') {
        throw new Error('Expected `resolverValidationOptions` to be an object');
    }
    const transformedSubschemas = [];
    const subschemaMap = new Map();
    const originalSubschemaMap = new Map();
    for (const subschemaOrSubschemaArray of subschemas) {
        if (Array.isArray(subschemaOrSubschemaArray)) {
            for (const s of subschemaOrSubschemaArray) {
                for (const transformedSubschemaConfig of applySubschemaConfigTransforms(subschemaConfigTransforms, s, subschemaMap, originalSubschemaMap)) {
                    transformedSubschemas.push(transformedSubschemaConfig);
                }
            }
        }
        else {
            for (const transformedSubschemaConfig of applySubschemaConfigTransforms(subschemaConfigTransforms, subschemaOrSubschemaArray, subschemaMap, originalSubschemaMap)) {
                transformedSubschemas.push(transformedSubschemaConfig);
            }
        }
    }
    const extensions = [];
    const directiveMap = Object.create(null);
    for (const directive of graphql.specifiedDirectives) {
        directiveMap[directive.name] = directive;
    }
    const schemaDefs = Object.create(null);
    const [typeCandidates, rootTypeNameMap] = buildTypeCandidates({
        subschemas: transformedSubschemas,
        originalSubschemaMap,
        types,
        typeDefs: typeDefs || [],
        parseOptions,
        extensions,
        directiveMap,
        schemaDefs,
        mergeDirectives,
    });
    let stitchingInfo = createStitchingInfo(subschemaMap, typeCandidates, mergeTypes);
    const { typeMap: newTypeMap, directives: newDirectives } = buildTypes({
        typeCandidates,
        directives: Object.values(directiveMap),
        stitchingInfo,
        rootTypeNames: Object.values(rootTypeNameMap),
        onTypeConflict,
        mergeTypes,
        typeMergingOptions,
    });
    let schema$1 = new graphql.GraphQLSchema({
        query: newTypeMap[rootTypeNameMap.query],
        mutation: newTypeMap[rootTypeNameMap.mutation],
        subscription: newTypeMap[rootTypeNameMap.subscription],
        types: Object.values(newTypeMap),
        directives: newDirectives,
        astNode: schemaDefs.schemaDef,
        extensionASTNodes: schemaDefs.schemaExtensions,
        extensions: null,
    });
    for (const extension of extensions) {
        schema$1 = graphql.extendSchema(schema$1, extension, {
            commentDescriptions: true,
        });
    }
    // We allow passing in an array of resolver maps, in which case we merge them
    const resolverMap = merge.mergeResolvers(resolvers);
    const finalResolvers = inheritResolversFromInterfaces
        ? schema.extendResolversFromInterfaces(schema$1, resolverMap)
        : resolverMap;
    stitchingInfo = completeStitchingInfo(stitchingInfo, finalResolvers, schema$1);
    schema$1 = schema.addResolversToSchema({
        schema: schema$1,
        defaultFieldResolver: delegate.defaultMergedResolver,
        resolvers: finalResolvers,
        resolverValidationOptions,
        inheritResolversFromInterfaces: false,
        updateResolversInPlace,
    });
    if (Object.keys(resolverValidationOptions).length > 0 &&
        Object.values(resolverValidationOptions).some(o => o !== 'ignore')) {
        schema.assertResolversPresent(schema$1, resolverValidationOptions);
    }
    schema$1 = addStitchingInfo(schema$1, stitchingInfo);
    if (pruningOptions) {
        schema$1 = utils.pruneSchema(schema$1, pruningOptions);
    }
    if (schemaExtensions) {
        if (Array.isArray(schemaExtensions)) {
            schemaExtensions = merge.mergeExtensions(schemaExtensions);
        }
        merge.applyExtensions(schema$1, schemaExtensions);
    }
    return schema$1;
}
const subschemaConfigTransformerPresets = [
    isolateComputedFieldsTransformer,
    splitMergedTypeEntryPointsTransformer,
];
function applySubschemaConfigTransforms(subschemaConfigTransforms, subschemaOrSubschemaConfig, subschemaMap, originalSubschemaMap) {
    let subschemaConfig;
    if (delegate.isSubschemaConfig(subschemaOrSubschemaConfig)) {
        subschemaConfig = subschemaOrSubschemaConfig;
    }
    else if (subschemaOrSubschemaConfig instanceof graphql.GraphQLSchema) {
        subschemaConfig = { schema: subschemaOrSubschemaConfig };
    }
    else {
        throw new TypeError('Received invalid input.');
    }
    const transformedSubschemaConfigs = subschemaConfigTransforms
        .concat(subschemaConfigTransformerPresets)
        .reduce((transformedSubschemaConfigs, subschemaConfigTransform) => transformedSubschemaConfigs.flatMap(ssConfig => subschemaConfigTransform(ssConfig)), [subschemaConfig]);
    const transformedSubschemas = transformedSubschemaConfigs.map(ssConfig => new delegate.Subschema(ssConfig));
    const baseSubschema = transformedSubschemas[0];
    subschemaMap.set(subschemaOrSubschemaConfig, baseSubschema);
    for (const subschema of transformedSubschemas) {
        originalSubschemaMap.set(subschema, subschemaOrSubschemaConfig);
    }
    return transformedSubschemas;
}

const forwardArgsToSelectionSet = (selectionSet, mapping) => {
    const selectionSetDef = utils.parseSelectionSet(selectionSet, { noLocation: true });
    return (field) => {
        const selections = selectionSetDef.selections.map((selectionNode) => {
            var _a, _b;
            if (selectionNode.kind === graphql.Kind.FIELD) {
                if (!mapping) {
                    return { ...selectionNode, arguments: (_a = field.arguments) === null || _a === void 0 ? void 0 : _a.slice() };
                }
                else if (selectionNode.name.value in mapping) {
                    const selectionArgs = mapping[selectionNode.name.value];
                    return {
                        ...selectionNode,
                        arguments: (_b = field.arguments) === null || _b === void 0 ? void 0 : _b.filter((arg) => selectionArgs.includes(arg.name.value)),
                    };
                }
            }
            return selectionNode;
        });
        return { ...selectionSetDef, selections };
    };
};

const defaultRelayMergeConfig = {
    selectionSet: `{ id }`,
    fieldName: 'node',
    args: ({ id }) => ({ id }),
};
function handleRelaySubschemas(subschemas, getTypeNameFromId) {
    const typeNames = [];
    for (const subschema of subschemas) {
        const nodeType = subschema.schema.getType('Node');
        if (nodeType) {
            if (!graphql.isInterfaceType(nodeType)) {
                throw new Error(`Node type should be an interface!`);
            }
            const implementations = subschema.schema.getPossibleTypes(nodeType);
            for (const implementedType of implementations) {
                typeNames.push(implementedType.name);
                subschema.merge = subschema.merge || {};
                subschema.merge[implementedType.name] = defaultRelayMergeConfig;
            }
        }
    }
    const relaySubschemaConfig = {
        schema: schema.makeExecutableSchema({
            typeDefs: /* GraphQL */ `
        type Query {
          node(id: ID!): Node
        }
        interface Node {
          id: ID!
        }
        ${typeNames
                .map(typeName => `
          type ${typeName} implements Node {
            id: ID!
          }
        `)
                .join('\n')}
      `,
            resolvers: {
                Query: {
                    node: (_, { id }) => ({ id }),
                },
                Node: {
                    __resolveType: ({ id }, _, info) => {
                        var _a, _b, _c;
                        if (!getTypeNameFromId) {
                            const possibleTypeNames = new Set();
                            for (const fieldNode of info.fieldNodes) {
                                if ((_a = fieldNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) {
                                    for (const selection of ((_b = fieldNode.selectionSet) === null || _b === void 0 ? void 0 : _b.selections) || []) {
                                        switch (selection.kind) {
                                            case graphql.Kind.FRAGMENT_SPREAD: {
                                                const fragment = info.fragments[selection.name.value];
                                                possibleTypeNames.add(fragment.typeCondition.name.value);
                                                break;
                                            }
                                            case graphql.Kind.INLINE_FRAGMENT: {
                                                const possibleTypeName = (_c = selection.typeCondition) === null || _c === void 0 ? void 0 : _c.name.value;
                                                if (possibleTypeName) {
                                                    possibleTypeNames.add(possibleTypeName);
                                                }
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            if (possibleTypeNames.size !== 1) {
                                console.warn(`You need to define getTypeNameFromId as a parameter to handleRelaySubschemas or add a fragment for "node" operation with specific single type condition!`);
                            }
                            return [...possibleTypeNames][0] || typeNames[0];
                        }
                        return getTypeNameFromId(id);
                    },
                },
            },
        }),
    };
    subschemas.push(relaySubschemaConfig);
    return subschemas;
}

exports.computedDirectiveTransformer = computedDirectiveTransformer;
exports.createMergedTypeResolver = createMergedTypeResolver;
exports.defaultSubschemaConfigTransforms = defaultSubschemaConfigTransforms;
exports.forwardArgsToSelectionSet = forwardArgsToSelectionSet;
exports.handleRelaySubschemas = handleRelaySubschemas;
exports.isolateComputedFieldsTransformer = isolateComputedFieldsTransformer;
exports.splitMergedTypeEntryPointsTransformer = splitMergedTypeEntryPointsTransformer;
exports.stitchSchemas = stitchSchemas;
