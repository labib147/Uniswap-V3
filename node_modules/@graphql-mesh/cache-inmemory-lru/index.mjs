import { createLruCache } from '@graphql-mesh/utils';

class InMemoryLRUCache {
    constructor(options) {
        this.cacheIdentifier = Date.now();
        this.lruCache = createLruCache(options === null || options === void 0 ? void 0 : options.max, options === null || options === void 0 ? void 0 : options.ttl);
    }
    nextTick() {
        // Make sure this is scheduled for next tick because LRU Cache is synchronous
        // This helps for testing multiple Mesh instances pointing to the same cache
        return new Promise(resolve => setTimeout(resolve));
    }
    async get(key) {
        await this.nextTick();
        const entry = this.lruCache.get(`${this.cacheIdentifier}-${key}`);
        if ((entry === null || entry === void 0 ? void 0 : entry.expiresAt) && Date.now() > entry.expiresAt) {
            this.lruCache.delete(key);
            return undefined;
        }
        return entry === null || entry === void 0 ? void 0 : entry.value;
    }
    async set(key, value, options) {
        await this.nextTick();
        this.lruCache.set(`${this.cacheIdentifier}-${key}`, {
            expiresAt: (options === null || options === void 0 ? void 0 : options.ttl) ? Date.now() + options.ttl * 1000 : Infinity,
            value,
        });
    }
    async delete(key) {
        await this.nextTick();
        this.lruCache.delete(`${this.cacheIdentifier}-${key}`);
    }
}

export default InMemoryLRUCache;
