import { path } from '@graphql-mesh/cross-helpers';
import { print } from 'graphql';
import { printSchemaWithDirectives } from '@graphql-tools/utils';
import { paramCase } from 'param-case';
import { loadTypedefs, loadDocuments } from '@graphql-tools/load';
import { GraphQLFileLoader } from '@graphql-tools/graphql-file-loader';
import { parseWithCache, PubSub, DefaultLogger, resolveAdditionalResolvers, defaultImportFn } from '@graphql-mesh/utils';
import { CodeFileLoader } from '@graphql-tools/code-file-loader';
import { MeshStore, FsStoreStorageAdapter, InMemoryStoreStorageAdapter } from '@graphql-mesh/store';
import { pascalCase } from 'pascal-case';
import { camelCase } from 'camel-case';

async function getPackage({ name, type, importFn, cwd }) {
    const casedName = paramCase(name);
    const casedType = paramCase(type);
    const possibleNames = [
        `@graphql-mesh/${casedName}`,
        `@graphql-mesh/${casedName}-${casedType}`,
        `@graphql-mesh/${casedType}-${casedName}`,
        casedName,
        `${casedName}-${casedType}`,
        `${casedType}-${casedName}`,
        casedType,
    ];
    if (name.includes('-')) {
        possibleNames.push(name);
    }
    const possibleModules = possibleNames.concat(path.resolve(cwd, name));
    for (const moduleName of possibleModules) {
        try {
            const exported = await importFn(moduleName);
            const resolved = exported.default || exported;
            return {
                moduleName,
                resolved,
            };
        }
        catch (err) {
            const error = err;
            if (!error.message.includes(`Cannot find module '${moduleName}'`) &&
                !error.message.includes(`Cannot find package '${moduleName}'`) &&
                !error.message.includes(`Could not locate module`)) {
                throw new Error(`Unable to load ${type} matching ${name}: ${error.message}`);
            }
        }
    }
    throw new Error(`Unable to find ${type} matching ${name}`);
}
async function resolveAdditionalTypeDefs(baseDir, additionalTypeDefs) {
    if (additionalTypeDefs) {
        const sources = await loadTypedefs(additionalTypeDefs, {
            cwd: baseDir,
            loaders: [new CodeFileLoader(), new GraphQLFileLoader()],
        });
        return sources.map(source => source.document || parseWithCache(source.rawSDL || printSchemaWithDirectives(source.schema)));
    }
    return undefined;
}
async function resolveCache(cacheConfig = { inmemoryLru: {} }, importFn, rootStore, cwd, pubsub) {
    const cacheName = Object.keys(cacheConfig)[0].toString();
    const config = cacheConfig[cacheName];
    const { moduleName, resolved: Cache } = await getPackage({ name: cacheName, type: 'cache', importFn, cwd });
    const cache = new Cache({
        ...config,
        importFn,
        store: rootStore.child('cache'),
        pubsub,
    });
    const code = `const cache = new (MeshCache as any)({
      ...(rawConfig.cache || {}),
      importFn,
      store: rootStore.child('cache'),
      pubsub,
    } as any)`;
    const importCode = `import MeshCache from '${moduleName}';`;
    return {
        cache,
        importCode,
        code,
    };
}
async function resolvePubSub(pubsubYamlConfig, importFn, cwd) {
    if (pubsubYamlConfig) {
        let pubsubName;
        let pubsubConfig;
        if (typeof pubsubYamlConfig === 'string') {
            pubsubName = pubsubYamlConfig;
        }
        else {
            pubsubName = pubsubYamlConfig.name;
            pubsubConfig = pubsubYamlConfig.config;
        }
        const { moduleName, resolved: PubSub } = await getPackage({ name: pubsubName, type: 'pubsub', importFn, cwd });
        const pubsub = new PubSub(pubsubConfig);
        const importCode = `import PubSub from '${moduleName}'`;
        const code = `const pubsub = new PubSub(rawConfig.pubsub);`;
        return {
            importCode,
            code,
            pubsub,
        };
    }
    else {
        const pubsub = new PubSub();
        const importCode = `import { PubSub } from '@graphql-mesh/utils';`;
        const code = `const pubsub = new PubSub();`;
        return {
            importCode,
            code,
            pubsub,
        };
    }
}
async function resolveDocuments(documentsConfig, cwd) {
    if (!documentsConfig) {
        return [];
    }
    return loadDocuments(documentsConfig, {
        loaders: [new CodeFileLoader(), new GraphQLFileLoader()],
        skipGraphQLImport: true,
        cwd,
    });
}
async function resolveLogger(loggerConfig, importFn, cwd) {
    if (typeof loggerConfig === 'string') {
        const { moduleName, resolved: logger } = await getPackage({
            name: loggerConfig,
            type: 'logger',
            importFn,
            cwd,
        });
        return {
            logger,
            importCode: `import logger from '${moduleName}';`,
            code: '',
        };
    }
    const logger = new DefaultLogger('🕸️');
    return {
        logger,
        importCode: `import { DefaultLogger } from '@graphql-mesh/utils';`,
        code: `const logger = new DefaultLogger('🕸️');`,
    };
}

function getDefaultMeshStore(dir, importFn, artifactsDir) {
    var _a;
    const isProd = ((_a = process.env.NODE_ENV) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'production';
    const storeStorageAdapter = isProd
        ? new FsStoreStorageAdapter({
            cwd: dir,
            importFn,
            fileType: 'ts',
        })
        : new InMemoryStoreStorageAdapter();
    return new MeshStore(path.resolve(dir, artifactsDir), storeStorageAdapter, {
        /**
         * TODO:
         * `mesh start` => { readonly: true, validate: false }
         * `mesh dev` => { readonly: false, validate: true } => validation error should show a prompt for confirmation
         * `mesh validate` => { readonly: true, validate: true } => should fetch from remote and try to update
         * readonly
         */
        readonly: isProd,
        validate: false,
    });
}
async function processConfig(config, options) {
    var _a;
    if (config.skipSSLValidation) {
        process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';
    }
    const importCodes = [
        `import { GetMeshOptions } from '@graphql-mesh/runtime';`,
        `import { YamlConfig } from '@graphql-mesh/types';`,
        `import { parse } from 'graphql';`,
    ];
    const codes = [
        `export const rawConfig: YamlConfig.Config = ${JSON.stringify(config)} as any`,
        `export async function getMeshOptions(): Promise<GetMeshOptions> {`,
    ];
    const { dir, importFn = defaultImportFn, store: providedStore, artifactsDir } = options || {};
    if (config.require) {
        await Promise.all(config.require.map(mod => importFn(mod)));
        for (const mod of config.require) {
            importCodes.push(`import '${mod}';`);
        }
    }
    const rootStore = providedStore || getDefaultMeshStore(dir, importFn, artifactsDir || '.mesh');
    const { pubsub, importCode: pubsubImportCode, code: pubsubCode } = await resolvePubSub(config.pubsub, importFn, dir);
    importCodes.push(pubsubImportCode);
    codes.push(pubsubCode);
    const { cache, importCode: cacheImportCode, code: cacheCode, } = await resolveCache(config.cache, importFn, rootStore, dir, pubsub);
    importCodes.push(cacheImportCode);
    codes.push(cacheCode);
    const sourcesStore = rootStore.child('sources');
    codes.push(`const sourcesStore = rootStore.child('sources');`);
    const { logger, importCode: loggerImportCode, code: loggerCode } = await resolveLogger(config.logger, importFn, dir);
    importCodes.push(loggerImportCode);
    codes.push(loggerCode);
    codes.push(`const sources = [];`);
    codes.push(`const transforms = [];`);
    const mergerName = config.merger || (config.sources.length > 1 ? 'stitching' : 'bare');
    const [sources, transforms, additionalTypeDefs, additionalResolvers, merger, documents] = await Promise.all([
        Promise.all(config.sources.map(async (source, sourceIndex) => {
            const handlerName = Object.keys(source.handler)[0].toString();
            const handlerConfig = source.handler[handlerName];
            const handlerVariableName = camelCase(`${source.name}_Handler`);
            const transformsVariableName = camelCase(`${source.name}_Transforms`);
            codes.push(`const ${transformsVariableName} = [];`);
            const [handler, transforms] = await Promise.all([
                await getPackage({ name: handlerName, type: 'handler', importFn, cwd: dir }).then(({ resolved: HandlerCtor, moduleName }) => {
                    const handlerImportName = pascalCase(handlerName + '_Handler');
                    importCodes.push(`import ${handlerImportName} from '${moduleName}'`);
                    codes.push(`const ${handlerVariableName} = new ${handlerImportName}({
              name: rawConfig.sources[${sourceIndex}].name,
              config: rawConfig.sources[${sourceIndex}].handler[${JSON.stringify(handlerName)}],
              baseDir,
              cache,
              pubsub,
              store: sourcesStore.child(rawConfig.sources[${sourceIndex}].name),
              logger: logger.child(rawConfig.sources[${sourceIndex}].name),
              importFn
            });`);
                    return new HandlerCtor({
                        name: source.name,
                        config: handlerConfig,
                        baseDir: dir,
                        cache,
                        pubsub,
                        store: sourcesStore.child(source.name),
                        logger: logger.child(source.name),
                        importFn,
                    });
                }),
                Promise.all((source.transforms || []).map(async (t, transformIndex) => {
                    const transformName = Object.keys(t)[0].toString();
                    const transformConfig = t[transformName];
                    const { resolved: TransformCtor, moduleName } = await getPackage({
                        name: transformName,
                        type: 'transform',
                        importFn,
                        cwd: dir,
                    });
                    const transformImportName = pascalCase(transformName + '_Transform');
                    importCodes.push(`import ${transformImportName} from '${moduleName}';`);
                    codes.push(`${transformsVariableName}.push(
                new ${transformImportName}({
                  apiName: rawConfig.sources[${sourceIndex}].name,
                  config: rawConfig.sources[${sourceIndex}].transforms[${transformIndex}][${JSON.stringify(transformName)}],
                  baseDir,
                  cache,
                  pubsub,
                  importFn
                })
              );`);
                    return new TransformCtor({
                        apiName: source.name,
                        config: transformConfig,
                        baseDir: dir,
                        cache,
                        pubsub,
                        importFn,
                    });
                })),
            ]);
            codes.push(`sources.push({
          name: '${source.name}',
          handler: ${handlerVariableName},
          transforms: ${transformsVariableName}
        })`);
            return {
                name: source.name,
                handler,
                transforms,
            };
        })),
        Promise.all(((_a = config.transforms) === null || _a === void 0 ? void 0 : _a.map(async (t, transformIndex) => {
            const transformName = Object.keys(t)[0].toString();
            const transformConfig = t[transformName];
            const { resolved: TransformLibrary, moduleName } = await getPackage({
                name: transformName,
                type: 'transform',
                importFn,
                cwd: dir,
            });
            const transformImportName = pascalCase(transformName + '_Transform');
            importCodes.push(`import ${transformImportName} from '${moduleName}';`);
            codes.push(`transforms.push(
          new (${transformImportName} as any)({
            apiName: '',
            config: rawConfig.transforms[${transformIndex}][${JSON.stringify(transformName)}],
            baseDir,
            cache,
            pubsub,
            importFn
          })
        )`);
            return new TransformLibrary({
                apiName: '',
                config: transformConfig,
                baseDir: dir,
                cache,
                pubsub,
                importFn,
            });
        })) || []),
        resolveAdditionalTypeDefs(dir, config.additionalTypeDefs).then(additionalTypeDefs => {
            codes.push(`const additionalTypeDefs = [${(additionalTypeDefs || []).map(parsedTypeDefs => `parse(${JSON.stringify(print(parsedTypeDefs))}),`)}] as any[];`);
            return additionalTypeDefs;
        }),
        (options === null || options === void 0 ? void 0 : options.ignoreAdditionalResolvers)
            ? []
            : resolveAdditionalResolvers(dir, config.additionalResolvers, importFn, pubsub),
        getPackage({ name: mergerName, type: 'merger', importFn, cwd: dir }).then(({ resolved: Merger, moduleName }) => {
            const mergerImportName = pascalCase(`${mergerName}Merger`);
            importCodes.push(`import ${mergerImportName} from '${moduleName}';`);
            codes.push(`const merger = new(${mergerImportName} as any)({
        cache,
        pubsub,
        logger: logger.child('${mergerImportName}'),
        store: rootStore.child('${mergerName}Merger')
      })`);
            return new Merger({
                cache,
                pubsub,
                logger: logger.child(mergerImportName),
                store: rootStore.child(`${mergerName}Merger`),
            });
        }),
        resolveDocuments(config.documents, dir),
    ]);
    importCodes.push(`import { resolveAdditionalResolvers } from '@graphql-mesh/utils';`);
    codes.push(`const additionalResolversRawConfig = [];`);
    for (const additionalResolverDefinitionIndex in config.additionalResolvers) {
        const additionalResolverDefinition = config.additionalResolvers[additionalResolverDefinitionIndex];
        if (typeof additionalResolverDefinition === 'string') {
            importCodes.push(`import * as additionalResolvers$${additionalResolverDefinitionIndex} from '${path
                .join('..', additionalResolverDefinition)
                .split('\\')
                .join('/')}';`);
            codes.push(`additionalResolversRawConfig.push(additionalResolvers$${additionalResolverDefinitionIndex}.resolvers || additionalResolvers$${additionalResolverDefinitionIndex}.default || additionalResolvers$${additionalResolverDefinitionIndex})`);
        }
        else {
            codes.push(`additionalResolversRawConfig.push(rawConfig.additionalResolvers[${additionalResolverDefinitionIndex}]);`);
        }
    }
    codes.push(`const additionalResolvers = await resolveAdditionalResolvers(
      baseDir,
      additionalResolversRawConfig,
      importFn,
      pubsub
  )`);
    codes.push(`const liveQueryInvalidations = rawConfig.liveQueryInvalidations;`);
    let additionalEnvelopPlugins = [];
    if (config.additionalEnvelopPlugins) {
        importCodes.push(`import importedAdditionalEnvelopPlugins from '${path
            .join('..', config.additionalEnvelopPlugins)
            .split('\\')
            .join('/')}';`);
        const importedAdditionalEnvelopPlugins = await importFn(path.isAbsolute(config.additionalEnvelopPlugins)
            ? config.additionalEnvelopPlugins
            : path.join(dir, config.additionalEnvelopPlugins));
        if (typeof importedAdditionalEnvelopPlugins === 'function') {
            const factoryResult = await importedAdditionalEnvelopPlugins(config);
            if (Array.isArray(factoryResult)) {
                codes.push(`const additionalEnvelopPlugins = await importedAdditionalEnvelopPlugins(rawConfig);`);
                additionalEnvelopPlugins = factoryResult;
            }
            else {
                codes.push(`const additionalEnvelopPlugins = [await importedAdditionalEnvelopPlugins(rawConfig)];`);
                additionalEnvelopPlugins = [factoryResult];
            }
        }
        else {
            if (Array.isArray(importedAdditionalEnvelopPlugins)) {
                codes.push(`const additionalEnvelopPlugins = importedAdditionalEnvelopPlugins;`);
                additionalEnvelopPlugins = importedAdditionalEnvelopPlugins;
            }
            else {
                additionalEnvelopPlugins = [importedAdditionalEnvelopPlugins];
                codes.push(`const additionalEnvelopPlugins = [importedAdditionalEnvelopPlugins];`);
            }
        }
    }
    else {
        codes.push(`const additionalEnvelopPlugins = [];`);
    }
    importCodes.push(`import { parseWithCache } from '@graphql-mesh/utils';`);
    codes.push(`const documents = documentsInSDL.map((documentSdl: string, i: number) => ({
              rawSDL: documentSdl,
              document: parseWithCache(documentSdl),
              location: \`document_\${i}.graphql\`,
            }))`);
    codes.push(`
  return {
    sources,
    transforms,
    additionalTypeDefs,
    additionalResolvers,
    cache,
    pubsub,
    merger,
    logger,
    liveQueryInvalidations,
    additionalEnvelopPlugins,
    documents,
  };
}`);
    return {
        sources,
        transforms,
        additionalTypeDefs,
        additionalResolvers,
        cache,
        merger,
        pubsub,
        config,
        documents,
        logger,
        store: rootStore,
        additionalEnvelopPlugins,
        code: [...new Set([...importCodes, ...codes])].join('\n'),
    };
}

export { getPackage, processConfig, resolveAdditionalTypeDefs, resolveCache, resolveDocuments, resolveLogger, resolvePubSub };
