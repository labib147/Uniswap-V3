#!/usr/bin/env node
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

const utils = require('@graphql-mesh/utils');
const config = require('@graphql-mesh/config');
const types = require('@graphql-mesh/types');
const Ajv = _interopDefault(require('ajv'));
const cosmiconfig = require('cosmiconfig');
const crossHelpers = require('@graphql-mesh/cross-helpers');
const runtime = require('@graphql-mesh/runtime');
const tsBasePlugin = require('@graphql-codegen/typescript');
const tsResolversPlugin = require('@graphql-codegen/typescript-resolvers');
const graphql = require('graphql');
const core = require('@graphql-codegen/core');
const pascalCase = require('pascal-case');
const utils$1 = require('@graphql-tools/utils');
const tsOperationsPlugin = require('@graphql-codegen/typescript-operations');
const typescriptGenericSdk = require('@graphql-codegen/typescript-generic-sdk');
const typedDocumentNodePlugin = require('@graphql-codegen/typed-document-node');
const ts = _interopDefault(require('typescript'));
const express = _interopDefault(require('express'));
const cluster = _interopDefault(require('cluster'));
const os = require('os');
require('json-bigint-patch');
const http = require('http');
const renderGraphiql = require('@graphql-yoga/render-graphiql');
const ws = _interopDefault(require('ws'));
const cors = _interopDefault(require('cors'));
const _ = _interopDefault(require('lodash'));
const bodyParser = _interopDefault(require('body-parser'));
const cookieParser = _interopDefault(require('cookie-parser'));
const node = require('@graphql-yoga/node');
const https = require('https');
const process$1 = require('process');
const open = _interopDefault(require('open'));
const ws$1 = require('graphql-ws/lib/use/ws');
const dnscache = _interopDefault(require('dnscache'));
const store = require('@graphql-mesh/store');
const yargs = _interopDefault(require('yargs'));
const helpers = require('yargs/helpers');
const tsNode = require('ts-node');
const tsconfigPaths = require('tsconfig-paths');
const dotenv = require('dotenv');
const util = require('util');

function validateConfig(config) {
    const ajv = new Ajv({
        strict: false,
    });
    types.jsonSchema.$schema = undefined;
    const isValid = ajv.validate(types.jsonSchema, config);
    if (!isValid) {
        console.warn(`Configuration is not valid:\n${ajv.errorsText()}`);
    }
}
async function findAndParseConfig(options) {
    const { configName = 'mesh', dir: configDir = '', ...restOptions } = options || {};
    const dir = crossHelpers.path.isAbsolute(configDir) ? configDir : crossHelpers.path.join(process.cwd(), configDir);
    const explorer = cosmiconfig.cosmiconfig(configName, {
        searchPlaces: [
            'package.json',
            `.${configName}rc`,
            `.${configName}rc.json`,
            `.${configName}rc.yaml`,
            `.${configName}rc.yml`,
            `.${configName}rc.js`,
            `.${configName}rc.ts`,
            `.${configName}rc.cjs`,
            `${configName}.config.js`,
            `${configName}.config.cjs`,
        ],
        loaders: {
            '.json': customLoader('json', options === null || options === void 0 ? void 0 : options.importFn),
            '.yaml': customLoader('yaml', options === null || options === void 0 ? void 0 : options.importFn),
            '.yml': customLoader('yaml', options === null || options === void 0 ? void 0 : options.importFn),
            '.js': customLoader('js', options === null || options === void 0 ? void 0 : options.importFn),
            '.ts': customLoader('js', options === null || options === void 0 ? void 0 : options.importFn),
            noExt: customLoader('yaml', options === null || options === void 0 ? void 0 : options.importFn),
        },
    });
    const results = await explorer.search(dir);
    if (!results) {
        throw new Error(`No ${configName} config file found in "${dir}"!`);
    }
    const config$1 = results.config;
    validateConfig(config$1);
    return config.processConfig(config$1, { dir, ...restOptions });
}
function customLoader(ext, importFn = utils.defaultImportFn) {
    function loader(filepath, content) {
        if (process.env) {
            content = content.replace(/\$\{(.*?)\}/g, (_, variable) => {
                let varName = variable;
                let defaultValue = '';
                if (variable.includes(':')) {
                    const spl = variable.split(':');
                    varName = spl.shift();
                    defaultValue = spl.join(':');
                }
                return process.env[varName] || defaultValue;
            });
        }
        if (ext === 'json') {
            return cosmiconfig.defaultLoaders['.json'](filepath, content);
        }
        if (ext === 'yaml') {
            return utils.loadYaml(filepath, content);
        }
        if (ext === 'js') {
            return importFn(filepath);
        }
    }
    return loader;
}

function generateOperations(schema, options) {
    var _a;
    const sources = [];
    const rootTypeMap = utils$1.getRootTypeMap(schema);
    for (const [operationType, rootType] of rootTypeMap) {
        const fieldMap = rootType.getFields();
        for (const fieldName in fieldMap) {
            const operationNode = utils$1.buildOperationNodeForField({
                schema,
                kind: operationType,
                field: fieldName,
                depthLimit: options.selectionSetDepth,
            });
            const defaultName = `operation_${sources.length}`;
            const virtualFileName = ((_a = operationNode.name) === null || _a === void 0 ? void 0 : _a.value) || defaultName;
            const rawSDL = graphql.print(operationNode);
            const source = utils$1.parseGraphQLSDL(`${virtualFileName}.graphql`, rawSDL);
            sources.push(source);
        }
    }
    return sources;
}

const stripJSONComments = (data) => {
    const re = /\/\/(.*)/g;
    const re2 = /\/\*(.*)\*\//g;
    return data.replace(re, '').replace(re2, '');
};

const unifiedContextIdentifier = 'MeshContext';
class CodegenHelpers extends tsBasePlugin.TsVisitor {
    getTypeToUse(namedType) {
        if (this.scalars[namedType.name.value]) {
            return this._getScalar(namedType.name.value);
        }
        return this._getTypeForNode(namedType);
    }
}
function buildSignatureBasedOnRootFields(codegenHelpers, type, namespace) {
    if (!type) {
        return {};
    }
    const fields = type.getFields();
    const operationMap = {};
    for (const fieldName in fields) {
        const field = fields[fieldName];
        const argsExists = field.args && field.args.length > 0;
        const argsName = argsExists ? `${namespace}.${type.name}${field.name}Args` : '{}';
        const parentTypeNode = {
            kind: graphql.Kind.NAMED_TYPE,
            name: {
                kind: graphql.Kind.NAME,
                value: type.name,
            },
        };
        operationMap[fieldName] = `  /** ${field.description} **/\n  ${field.name}: InContextSdkMethod<${namespace}.${codegenHelpers.getTypeToUse(parentTypeNode)}['${fieldName}'], ${argsName}, ${unifiedContextIdentifier}>`;
    }
    return operationMap;
}
async function generateTypesForApi(options) {
    const baseTypes = await core.codegen({
        filename: options.name + '_types.ts',
        documents: [],
        config: {
            skipTypename: true,
            namingConvention: 'keep',
            enumsAsTypes: true,
            ignoreEnumValuesFromSchema: true,
        },
        schemaAst: options.schema,
        schema: undefined,
        skipDocumentsValidation: true,
        plugins: [
            {
                typescript: {},
            },
        ],
        pluginMap: {
            typescript: tsBasePlugin,
        },
    });
    const codegenHelpers = new CodegenHelpers(options.schema, {}, {});
    const namespace = pascalCase.pascalCase(`${options.name}Types`);
    const sdkIdentifier = pascalCase.pascalCase(`${options.name}Sdk`);
    const contextIdentifier = pascalCase.pascalCase(`${options.name}Context`);
    const queryOperationMap = buildSignatureBasedOnRootFields(codegenHelpers, options.schema.getQueryType(), namespace);
    const mutationOperationMap = buildSignatureBasedOnRootFields(codegenHelpers, options.schema.getMutationType(), namespace);
    const subscriptionsOperationMap = buildSignatureBasedOnRootFields(codegenHelpers, options.schema.getSubscriptionType(), namespace);
    const sdk = {
        identifier: sdkIdentifier,
        codeAst: `
    export namespace ${namespace} {
      ${baseTypes}
    }
    export type Query${sdkIdentifier} = {
${Object.values(queryOperationMap).join(',\n')}
};

export type Mutation${sdkIdentifier} = {
${Object.values(mutationOperationMap).join(',\n')}
};

export type Subscription${sdkIdentifier} = {
${Object.values(subscriptionsOperationMap).join(',\n')}
};`,
    };
    const context = {
        identifier: contextIdentifier,
        codeAst: `export type ${contextIdentifier} = {
      ["${options.name}"]: { Query: Query${sdkIdentifier}, Mutation: Mutation${sdkIdentifier}, Subscription: Subscription${sdkIdentifier} },
    };`,
    };
    return {
        sdk,
        context,
    };
}
const BASEDIR_ASSIGNMENT_COMMENT = `/* BASEDIR_ASSIGNMENT */`;
async function generateTsArtifacts({ unifiedSchema, rawSources, mergerType = 'stitching', documents, flattenTypes, importedModulesSet, baseDir, meshConfigCode, logger, sdkConfig, tsOnly = true, codegenConfig = {}, }, cliParams) {
    var _a, _b, _c;
    const artifactsDir = crossHelpers.path.join(baseDir, cliParams.artifactsDir);
    logger.info('Generating index file in TypeScript');
    for (const rawSource of rawSources) {
        const transformedSchema = unifiedSchema.extensions.sourceMap.get(rawSource);
        const sdl = utils$1.printSchemaWithDirectives(transformedSchema);
        await utils.writeFile(crossHelpers.path.join(artifactsDir, `sources/${rawSource.name}/schema.graphql`), sdl);
    }
    const codegenOutput = '// @ts-nocheck\n' +
        (await core.codegen({
            filename: 'types.ts',
            documents: (sdkConfig === null || sdkConfig === void 0 ? void 0 : sdkConfig.generateOperations)
                ? generateOperations(unifiedSchema, sdkConfig.generateOperations)
                : documents,
            config: {
                skipTypename: true,
                flattenGeneratedTypes: flattenTypes,
                onlyOperationTypes: flattenTypes,
                preResolveTypes: flattenTypes,
                namingConvention: 'keep',
                documentMode: 'graphQLTag',
                gqlImport: '@graphql-mesh/utils#gql',
                enumsAsTypes: true,
                ignoreEnumValuesFromSchema: true,
                useIndexSignature: true,
                noSchemaStitching: mergerType !== 'stitching',
                contextType: unifiedContextIdentifier,
                federation: mergerType === 'federation',
                ...codegenConfig,
            },
            schemaAst: unifiedSchema,
            schema: undefined,
            skipDocumentsValidation: true,
            pluginMap: {
                typescript: tsBasePlugin,
                typescriptOperations: tsOperationsPlugin,
                typedDocumentNode: typedDocumentNodePlugin,
                typescriptGenericSdk,
                resolvers: tsResolversPlugin,
                contextSdk: {
                    plugin: async () => {
                        const commonTypes = [
                            `import { MeshContext as BaseMeshContext, MeshInstance } from '@graphql-mesh/runtime';`,
                            `import { InContextSdkMethod } from '@graphql-mesh/types';`,
                        ];
                        const sdkItems = [];
                        const contextItems = [];
                        const results = await Promise.all(rawSources.map(async (source) => {
                            const sourceMap = unifiedSchema.extensions.sourceMap;
                            const sourceSchema = sourceMap.get(source);
                            const item = await generateTypesForApi({
                                schema: sourceSchema,
                                name: source.name,
                            });
                            if (item) {
                                if (item.sdk) {
                                    sdkItems.push(item.sdk.codeAst);
                                }
                                if (item.context) {
                                    contextItems.push(item.context.codeAst);
                                }
                            }
                            return item;
                        }));
                        const contextType = `export type ${unifiedContextIdentifier} = ${results
                            .map(r => { var _a; return (_a = r === null || r === void 0 ? void 0 : r.context) === null || _a === void 0 ? void 0 : _a.identifier; })
                            .filter(Boolean)
                            .join(' & ')} & BaseMeshContext;`;
                        const importCodes = [
                            `import { getMesh } from '@graphql-mesh/runtime';`,
                            `import { MeshStore, FsStoreStorageAdapter } from '@graphql-mesh/store';`,
                            `import { path as pathModule } from '@graphql-mesh/cross-helpers';`,
                            `import { fileURLToPath } from '@graphql-mesh/utils';`,
                        ];
                        const importedModulesCodes = [...importedModulesSet].map((importedModuleName, i) => {
                            let moduleMapProp = importedModuleName;
                            let importPath = importedModuleName;
                            if (importPath.startsWith('.')) {
                                importPath = crossHelpers.path.join(baseDir, importPath);
                            }
                            if (crossHelpers.path.isAbsolute(importPath)) {
                                moduleMapProp = crossHelpers.path.relative(baseDir, importedModuleName).split('\\').join('/');
                                importPath = `./${crossHelpers.path.relative(artifactsDir, importedModuleName).split('\\').join('/')}`;
                            }
                            const importedModuleVariable = pascalCase.pascalCase(`ExternalModule$${i}`);
                            importCodes.push(`import ${importedModuleVariable} from '${importPath}';`);
                            return `  // @ts-ignore\n  [${JSON.stringify(moduleMapProp)}]: ${importedModuleVariable}`;
                        });
                        const meshMethods = `
${importCodes.join('\n')}

const importedModules: Record<string, any> = {
${importedModulesCodes.join(',\n')}
};

${BASEDIR_ASSIGNMENT_COMMENT}

const importFn = (moduleId: string) => {
  const relativeModuleId = (pathModule.isAbsolute(moduleId) ? pathModule.relative(baseDir, moduleId) : moduleId).split('\\\\').join('/').replace(baseDir + '/', '');
  if (!(relativeModuleId in importedModules)) {
    throw new Error(\`Cannot find module '\${relativeModuleId}'.\`);
  }
  return Promise.resolve(importedModules[relativeModuleId]);
};

const rootStore = new MeshStore('${cliParams.artifactsDir}', new FsStoreStorageAdapter({
  cwd: baseDir,
  importFn,
  fileType: 'ts',
}), {
  readonly: true,
  validate: false
});

${meshConfigCode}

export const documentsInSDL = /*#__PURE__*/ [${documents.map(documentSource => `/* GraphQL */\`${documentSource.rawSDL}\``)}];

export async function ${cliParams.builtMeshFactoryName}(): Promise<MeshInstance<MeshContext>> {
  const meshConfig = await getMeshOptions();
  return getMesh<MeshContext>(meshConfig);
}

export async function ${cliParams.builtMeshSDKFactoryName}<TGlobalContext = any, TOperationContext = any>(globalContext?: TGlobalContext) {
  const { sdkRequesterFactory } = await ${cliParams.builtMeshFactoryName}();
  return getSdk<TOperationContext>(sdkRequesterFactory(globalContext));
}`;
                        return {
                            content: [...commonTypes, ...sdkItems, ...contextItems, contextType, meshMethods].join('\n\n'),
                        };
                    },
                },
            },
            plugins: [
                {
                    typescript: {},
                },
                {
                    resolvers: {},
                },
                {
                    contextSdk: {},
                },
                {
                    typescriptOperations: {},
                },
                {
                    typedDocumentNode: {},
                },
                {
                    typescriptGenericSdk: {
                        documentMode: 'external',
                        importDocumentNodeExternallyFrom: 'NOWHERE',
                    },
                },
            ],
        }))
            .replace(`import * as Operations from 'NOWHERE';\n`, '')
            .replace(`import { DocumentNode } from 'graphql';`, '');
    const baseUrlAssignmentESM = `const baseDir = pathModule.join(pathModule.dirname(fileURLToPath(import.meta.url)), '${crossHelpers.path.relative(artifactsDir, baseDir)}');`;
    const baseUrlAssignmentCJS = `const baseDir = pathModule.join(__dirname, '${crossHelpers.path.relative(artifactsDir, baseDir)}');`;
    const tsFilePath = crossHelpers.path.join(artifactsDir, 'index.ts');
    const jobs = [];
    const jsFilePath = crossHelpers.path.join(artifactsDir, 'index.js');
    const dtsFilePath = crossHelpers.path.join(artifactsDir, 'index.d.ts');
    const esmJob = (ext) => async () => {
        logger.info('Writing index.ts for ESM to the disk.');
        await utils.writeFile(tsFilePath, codegenOutput.replace(BASEDIR_ASSIGNMENT_COMMENT, baseUrlAssignmentESM));
        const esmJsFilePath = crossHelpers.path.join(artifactsDir, `index.${ext}`);
        if (await utils.pathExists(esmJsFilePath)) {
            await crossHelpers.fs.promises.unlink(esmJsFilePath);
        }
        if (!tsOnly) {
            logger.info(`Compiling TS file as ES Module to "index.${ext}"`);
            compileTS(tsFilePath, ts.ModuleKind.ESNext, [jsFilePath, dtsFilePath]);
            if (ext === 'mjs') {
                const mjsFilePath = crossHelpers.path.join(artifactsDir, 'index.mjs');
                await crossHelpers.fs.promises.rename(jsFilePath, mjsFilePath);
            }
            logger.info('Deleting index.ts');
            await crossHelpers.fs.promises.unlink(tsFilePath);
        }
    };
    const cjsJob = async () => {
        logger.info('Writing index.ts for CJS to the disk.');
        await utils.writeFile(tsFilePath, codegenOutput.replace(BASEDIR_ASSIGNMENT_COMMENT, baseUrlAssignmentCJS));
        if (await utils.pathExists(jsFilePath)) {
            await crossHelpers.fs.promises.unlink(jsFilePath);
        }
        if (!tsOnly) {
            logger.info('Compiling TS file as CommonJS Module to `index.js`');
            compileTS(tsFilePath, ts.ModuleKind.CommonJS, [jsFilePath, dtsFilePath]);
            logger.info('Deleting index.ts');
            await crossHelpers.fs.promises.unlink(tsFilePath);
        }
    };
    const packageJsonJob = (module) => () => utils.writeJSON(crossHelpers.path.join(artifactsDir, 'package.json'), {
        name: 'mesh-artifacts',
        private: true,
        type: module,
        main: 'index.js',
        module: 'index.mjs',
        sideEffects: false,
        typings: 'index.d.ts',
        typescript: {
            definition: 'index.d.ts',
        },
        exports: {
            '.': {
                require: './index.js',
                import: './index.mjs',
            },
            './*': {
                require: './*.js',
                import: './*.mjs',
            },
        },
    });
    const tsConfigPath = crossHelpers.path.join(baseDir, 'tsconfig.json');
    if (await utils.pathExists(tsConfigPath)) {
        const tsConfigStr = await crossHelpers.fs.promises.readFile(tsConfigPath, 'utf-8');
        const tsConfig = JSON.parse(stripJSONComments(tsConfigStr));
        if ((_c = (_b = (_a = tsConfig === null || tsConfig === void 0 ? void 0 : tsConfig.compilerOptions) === null || _a === void 0 ? void 0 : _a.module) === null || _b === void 0 ? void 0 : _b.toLowerCase()) === null || _c === void 0 ? void 0 : _c.startsWith('es')) {
            jobs.push(esmJob('js'));
            if (!tsOnly) {
                jobs.push(packageJsonJob('module'));
            }
        }
        else {
            jobs.push(cjsJob);
            if (!tsOnly) {
                jobs.push(packageJsonJob('commonjs'));
            }
        }
    }
    else {
        jobs.push(esmJob('mjs'));
        jobs.push(cjsJob);
        if (!tsOnly) {
            jobs.push(packageJsonJob('commonjs'));
        }
    }
    for (const job of jobs) {
        await job();
    }
}
function compileTS(tsFilePath, module, outputFilePaths) {
    const options = {
        target: ts.ScriptTarget.ESNext,
        module,
        sourceMap: false,
        inlineSourceMap: false,
        importHelpers: true,
        allowSyntheticDefaultImports: true,
        esModuleInterop: true,
        declaration: true,
    };
    const host = ts.createCompilerHost(options);
    const hostWriteFile = host.writeFile.bind(host);
    host.writeFile = (fileName, ...rest) => {
        if (outputFilePaths.some(f => crossHelpers.path.normalize(f) === crossHelpers.path.normalize(fileName))) {
            return hostWriteFile(fileName, ...rest);
        }
    };
    // Prepare and emit the d.ts files
    const program = ts.createProgram([tsFilePath], options, host);
    program.emit();
}

const playgroundMiddlewareFactory = ({ baseDir, graphqlPath, logger, title = 'GraphQL Mesh', }) => {
    return function (req, res, next) {
        if (req.query.query) {
            next();
            return;
        }
        res.send(renderGraphiql.renderGraphiQL({
            endpoint: graphqlPath,
            title,
        }));
    };
};

function shouldRenderGraphiQL(req) {
    return req.method.toLowerCase() === 'get' && req.headers.accept.includes('text/html');
}
const graphqlHandler = (mesh$) => {
    const yoga$ = mesh$.then(mesh => node.createServer({
        parserCache: false,
        validationCache: false,
        plugins: [
            ...mesh.plugins,
            node.useExtendContext(({ req, res }) => ({
                ...req,
                headers: req.headers,
                cookies: req.cookies,
                res,
            })),
        ],
        logging: mesh.logger,
        maskedErrors: false,
    }));
    return function (req, res, next) {
        // Determine whether we should render GraphiQL instead of returning an API response
        if (shouldRenderGraphiQL(req)) {
            next();
        }
        else {
            yoga$
                .then(yoga => yoga.requestListener(req, res))
                .catch((e) => {
                res.status(500);
                res.write(JSON.stringify({
                    errors: 'errors' in e
                        ? e.errors.map((e) => ({
                            name: e.name,
                            message: e.message,
                            stack: e.stack,
                        }))
                        : [
                            {
                                name: e.name,
                                message: e.message,
                                stack: e.stack,
                            },
                        ],
                }));
                res.end();
            });
        }
    };
};

function handleFatalError(e, logger = new utils.DefaultLogger('🕸️')) {
    logger.error(e.stack || e.message);
    console.log(e);
    if (process.env.JEST == null) {
        process$1.exit(1);
    }
}

/* eslint-disable dot-notation */
dnscache({ enable: true });
const terminateEvents = ['SIGINT', 'SIGTERM'];
function registerTerminateHandler(callback) {
    for (const eventName of terminateEvents) {
        process$1.on(eventName, () => callback(eventName));
    }
}
async function serveMesh({ baseDir, argsPort, getBuiltMesh, logger, rawConfig, playgroundTitle }, cliParams) {
    var _a, _b;
    const { fork, port: configPort, hostname = os.platform() === 'win32' ? 'localhost' : '0.0.0.0', cors: corsConfig, handlers, staticFiles, playground, maxRequestBodySize = '100kb', sslCredentials, endpoint: graphqlPath = '/graphql', browser, } = rawConfig.serve || {};
    const port = argsPort || parseInt(process$1.env.PORT) || configPort || 4000;
    const protocol = sslCredentials ? 'https' : 'http';
    const serverUrl = `${protocol}://${hostname}:${port}`;
    if (!playgroundTitle) {
        playgroundTitle = ((_a = rawConfig.serve) === null || _a === void 0 ? void 0 : _a.playgroundTitle) || cliParams.playgroundTitle;
    }
    if (!cluster.isWorker && Boolean(fork)) {
        const forkNum = fork > 0 && typeof fork === 'number' ? fork : os.cpus().length;
        for (let i = 0; i < forkNum; i++) {
            const worker = cluster.fork();
            registerTerminateHandler(eventName => worker.kill(eventName));
        }
        logger.info(`${cliParams.serveMessage}: ${serverUrl} in ${forkNum} forks`);
    }
    else {
        logger.info(`Generating the unified schema...`);
        let readyFlag = false;
        const mesh$ = getBuiltMesh()
            .then(mesh => {
            readyFlag = true;
            logger.info(`${cliParams.serveMessage}: ${serverUrl}`);
            registerTerminateHandler(eventName => {
                const eventLogger = logger.child(`${eventName}💀`);
                eventLogger.info(`Destroying the server`);
                mesh.destroy();
            });
            return mesh;
        })
            .catch(e => handleFatalError(e, logger));
        const app = express();
        app.set('trust proxy', 'loopback');
        let httpServer;
        if (sslCredentials) {
            const [key, cert] = await Promise.all([
                crossHelpers.fs.promises.readFile(sslCredentials.key, 'utf-8'),
                crossHelpers.fs.promises.readFile(sslCredentials.cert, 'utf-8'),
            ]);
            httpServer = https.createServer({ key, cert }, app);
        }
        else {
            httpServer = http.createServer(app);
        }
        registerTerminateHandler(eventName => {
            const eventLogger = logger.child(`${eventName}💀`);
            eventLogger.debug(() => `Stopping HTTP Server`);
            httpServer.close(error => {
                if (error) {
                    eventLogger.debug(() => `HTTP Server couldn't be stopped: ${error.message}`);
                }
                else {
                    eventLogger.debug(() => `HTTP Server has been stopped`);
                }
            });
        });
        if (corsConfig) {
            app.use(cors(corsConfig));
        }
        app.use(bodyParser.json({
            limit: maxRequestBodySize,
        }));
        app.use(cookieParser());
        const wsServer = new ws.Server({
            path: graphqlPath,
            server: httpServer,
        });
        registerTerminateHandler(eventName => {
            const eventLogger = logger.child(`${eventName}💀`);
            eventLogger.debug(() => `Stopping WebSocket Server`);
            wsServer.close(error => {
                if (error) {
                    eventLogger.debug(() => `WebSocket Server couldn't be stopped: ${error.message}`);
                }
                else {
                    eventLogger.debug(() => `WebSocket Server has been stopped`);
                }
            });
        });
        const { dispose: stopGraphQLWSServer } = ws$1.useServer({
            onSubscribe: async ({ connectionParams, extra: { request } }, msg) => {
                var _a;
                // spread connectionParams.headers to upgrade request headers.
                // we completely ignore the root connectionParams because
                // [@graphql-tools/url-loader adds the headers inside the "headers" field](https://github.com/ardatan/graphql-tools/blob/9a13357c4be98038c645f6efb26f0584828177cf/packages/loaders/url/src/index.ts#L597)
                for (const [key, value] of Object.entries((_a = connectionParams.headers) !== null && _a !== void 0 ? _a : {})) {
                    // dont overwrite existing upgrade headers due to security reasons
                    if (!(key.toLowerCase() in request.headers)) {
                        request.headers[key.toLowerCase()] = value;
                    }
                }
                const { getEnveloped } = await mesh$;
                const { schema, execute, subscribe, contextFactory, parse, validate } = getEnveloped(request);
                const args = {
                    schema,
                    operationName: msg.payload.operationName,
                    document: parse(msg.payload.query),
                    variableValues: msg.payload.variables,
                    contextValue: await contextFactory(),
                    execute,
                    subscribe,
                };
                const errors = validate(args.schema, args.document);
                if (errors.length)
                    return errors;
                return args;
            },
            execute: (args) => args.execute(args),
            subscribe: (args) => args.subscribe(args),
        }, wsServer);
        registerTerminateHandler(eventName => {
            const eventLogger = logger.child(`${eventName}💀`);
            eventLogger.debug(() => `Stopping GraphQL WS`);
            Promise.resolve()
                .then(() => stopGraphQLWSServer())
                .then(() => {
                eventLogger.debug(() => `GraphQL WS has been stopped`);
            })
                .catch(error => {
                eventLogger.debug(() => `GraphQL WS couldn't be stopped: ${error.message}`);
            });
        });
        const pubSubHandler = (req, _res, next) => {
            mesh$
                .then(({ pubsub }) => {
                req['pubsub'] = pubsub;
                next();
            })
                .catch(e => handleFatalError(e, logger));
        };
        app.use(pubSubHandler);
        const registeredPaths = new Set();
        await Promise.all((handlers === null || handlers === void 0 ? void 0 : handlers.map(async (handlerConfig) => {
            var _a;
            registeredPaths.add(handlerConfig.path);
            let handlerFn;
            const handlerLogger = logger.child(handlerConfig.path);
            if ('handler' in handlerConfig) {
                handlerFn = await utils.loadFromModuleExportExpression(handlerConfig.handler, {
                    cwd: baseDir,
                    defaultExportName: 'default',
                    importFn: utils.defaultImportFn,
                });
            }
            else if ('pubsubTopic' in handlerConfig) {
                handlerFn = (req, res) => {
                    let payload = req.body;
                    handlerLogger.debug(() => `Payload received; ${utils$1.inspect(payload)}`);
                    if (handlerConfig.payload) {
                        payload = _.get(payload, handlerConfig.payload);
                        handlerLogger.debug(() => `Extracting ${handlerConfig.payload}; ${utils$1.inspect(payload)}`);
                    }
                    const interpolationData = {
                        req,
                        res,
                        payload,
                    };
                    handlerLogger.debug(() => `Interpolating ${handlerConfig.pubsubTopic} with ${utils$1.inspect(interpolationData)}`);
                    const pubsubTopic = utils.stringInterpolator.parse(handlerConfig.pubsubTopic, interpolationData);
                    req['pubsub'].publish(pubsubTopic, payload);
                    handlerLogger.debug(() => `Payload sent to ${pubsubTopic}`);
                    res.end();
                };
            }
            app[((_a = handlerConfig.method) === null || _a === void 0 ? void 0 : _a.toLowerCase()) || 'use'](handlerConfig.path, handlerFn);
        })) || []);
        app.get('/healthcheck', (_req, res) => res.sendStatus(200));
        app.get('/readiness', (_req, res) => res.sendStatus(readyFlag ? 200 : 500));
        if (staticFiles) {
            app.use(express.static(staticFiles));
            const indexPath = crossHelpers.path.join(baseDir, staticFiles, 'index.html');
            if (await utils.pathExists(indexPath)) {
                app.get('/', (_req, res) => res.sendFile(indexPath));
            }
        }
        app.use(graphqlPath, graphqlHandler(mesh$));
        if (typeof playground !== 'undefined' ? playground : ((_b = process$1.env.NODE_ENV) === null || _b === void 0 ? void 0 : _b.toLowerCase()) !== 'production') {
            const playgroundMiddleware = playgroundMiddlewareFactory({
                baseDir,
                graphqlPath,
                logger,
                title: playgroundTitle,
            });
            if (!staticFiles) {
                app.get('/', playgroundMiddleware);
            }
            app.get(graphqlPath, playgroundMiddleware);
        }
        httpServer
            .listen(parseInt(port.toString()), hostname, () => {
            var _a;
            const shouldntOpenBrowser = ((_a = process$1.env.NODE_ENV) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'production' || browser === false;
            if (!shouldntOpenBrowser) {
                open(serverUrl, typeof browser === 'string' ? { app: browser } : undefined).catch(() => { });
            }
        })
            .on('error', handleFatalError);
        return mesh$.then(mesh => ({
            mesh,
            httpServer,
            app,
            readyFlag,
            logger: logger,
        }));
    }
    return null;
}

const DEFAULT_CLI_PARAMS = {
    commandName: 'mesh',
    initialLoggerPrefix: '🕸️',
    configName: 'mesh',
    artifactsDir: '.mesh',
    serveMessage: 'Serving GraphQL Mesh',
    playgroundTitle: 'GraphiQL Mesh',
    builtMeshFactoryName: 'getBuiltMesh',
    builtMeshSDKFactoryName: 'getMeshSDK',
    devServerCommand: 'dev',
    prodServerCommand: 'start',
    buildArtifactsCommand: 'build',
    sourceServerCommand: 'serve-source',
    validateCommand: 'validate',
};
async function graphqlMesh(cliParams = DEFAULT_CLI_PARAMS, args = helpers.hideBin(process.argv), cwdPath = process$1.cwd()) {
    let baseDir = cwdPath;
    let logger = new utils.DefaultLogger(cliParams.initialLoggerPrefix);
    return yargs(args)
        .help()
        .option('r', {
        alias: 'require',
        describe: 'Loads specific require.extensions before running the codegen and reading the configuration',
        type: 'array',
        default: [],
        coerce: (externalModules) => Promise.all(externalModules.map(module => {
            const localModulePath = crossHelpers.path.resolve(baseDir, module);
            const islocalModule = crossHelpers.fs.existsSync(localModulePath);
            return utils.defaultImportFn(islocalModule ? localModulePath : module);
        })),
    })
        .option('dir', {
        describe: 'Modified the base directory to use for looking for ' + cliParams.configName + ' config file',
        type: 'string',
        default: baseDir,
        coerce: dir => {
            var _a;
            if (crossHelpers.path.isAbsolute(dir)) {
                baseDir = dir;
            }
            else {
                baseDir = crossHelpers.path.resolve(cwdPath, dir);
            }
            const tsConfigPath = crossHelpers.path.join(baseDir, 'tsconfig.json');
            const tsConfigExists = crossHelpers.fs.existsSync(tsConfigPath);
            tsNode.register({
                transpileOnly: true,
                typeCheck: false,
                preferTsExts: true,
                dir: baseDir,
                require: ['graphql-import-node/register'],
                compilerOptions: {
                    module: 'commonjs',
                },
            });
            if (tsConfigExists) {
                try {
                    const tsConfigStr = crossHelpers.fs.readFileSync(tsConfigPath, 'utf-8');
                    const tsConfigStrWithoutComments = stripJSONComments(tsConfigStr);
                    const tsConfig = JSON.parse(tsConfigStrWithoutComments);
                    if ((_a = tsConfig.compilerOptions) === null || _a === void 0 ? void 0 : _a.paths) {
                        tsconfigPaths.register({
                            baseUrl: baseDir,
                            paths: tsConfig.compilerOptions.paths,
                        });
                    }
                }
                catch (e) {
                    logger.warn(`Unable to read TSConfig file ${tsConfigPath};\n ${e.stack || e.message || util.inspect(e)}`);
                }
            }
            if (crossHelpers.fs.existsSync(crossHelpers.path.join(baseDir, '.env'))) {
                dotenv.config({
                    path: crossHelpers.path.join(baseDir, '.env'),
                });
            }
        },
    })
        .command(cliParams.devServerCommand, 'Serves a GraphQL server with GraphQL interface by building artifacts on the fly', builder => {
        builder.option('port', {
            type: 'number',
        });
    }, async (args) => {
        var _a;
        try {
            const outputDir = crossHelpers.path.join(baseDir, cliParams.artifactsDir);
            process$1.env.NODE_ENV = 'development';
            const meshConfig = await findAndParseConfig({
                dir: baseDir,
                artifactsDir: cliParams.artifactsDir,
                configName: cliParams.configName,
            });
            logger = meshConfig.logger;
            const meshInstance$ = runtime.getMesh(meshConfig);
            meshInstance$
                .then(({ schema }) => utils.writeFile(crossHelpers.path.join(outputDir, 'schema.graphql'), graphql.printSchema(schema)))
                .catch(e => {
                logger.error(`An error occured while writing the schema file: ${e.stack || e.message}`);
            });
            meshInstance$
                .then(({ schema, rawSources }) => generateTsArtifacts({
                unifiedSchema: schema,
                rawSources,
                mergerType: meshConfig.merger.name,
                documents: meshConfig.documents,
                flattenTypes: false,
                importedModulesSet: new Set(),
                baseDir,
                meshConfigCode: `
                import { findAndParseConfig } from '@graphql-mesh/cli';
                function getMeshOptions() {
                  console.warn('WARNING: These artifacts are built for development mode. Please run "${cliParams.commandName} build" to build production artifacts');
                  return findAndParseConfig({
                    dir: baseDir,
                    artifactsDir: ${JSON.stringify(cliParams.artifactsDir)},
                    configName: ${JSON.stringify(cliParams.configName)},
                  });
                }
              `,
                logger,
                sdkConfig: meshConfig.config.sdk,
                tsOnly: true,
                codegenConfig: meshConfig.config.codegen,
            }, cliParams))
                .catch(e => {
                logger.error(`An error occurred while building the artifacts: ${e.stack || e.message}`);
            });
            const serveMeshOptions = {
                baseDir,
                argsPort: args.port,
                getBuiltMesh: () => meshInstance$,
                logger: meshConfig.logger.child('Server'),
                rawConfig: meshConfig.config,
            };
            if ((_a = meshConfig.config.serve) === null || _a === void 0 ? void 0 : _a.customServerHandler) {
                const customServerHandler = await utils.loadFromModuleExportExpression(meshConfig.config.serve.customServerHandler, {
                    defaultExportName: 'default',
                    cwd: baseDir,
                    importFn: utils.defaultImportFn,
                });
                await customServerHandler(serveMeshOptions);
            }
            else {
                await serveMesh(serveMeshOptions, cliParams);
            }
        }
        catch (e) {
            handleFatalError(e, logger);
        }
    })
        .command(cliParams.prodServerCommand, 'Serves a GraphQL server with GraphQL interface based on your generated artifacts', builder => {
        builder.option('port', {
            type: 'number',
        });
    }, async (args) => {
        var _a;
        try {
            const builtMeshArtifactsPath = crossHelpers.path.join(baseDir, cliParams.artifactsDir);
            if (!(await utils.pathExists(builtMeshArtifactsPath))) {
                throw new Error(`Seems like you haven't build the artifacts yet to start production server! You need to build artifacts first with "${cliParams.commandName} build" command!`);
            }
            process$1.env.NODE_ENV = 'production';
            const mainModule = crossHelpers.path.join(builtMeshArtifactsPath, 'index');
            const builtMeshArtifacts = await utils.defaultImportFn(mainModule);
            const getMeshOptions = await builtMeshArtifacts.getMeshOptions();
            logger = getMeshOptions.logger;
            const rawConfig = builtMeshArtifacts.rawConfig;
            const serveMeshOptions = {
                baseDir,
                argsPort: args.port,
                getBuiltMesh: () => runtime.getMesh(getMeshOptions),
                logger: getMeshOptions.logger.child('Server'),
                rawConfig: builtMeshArtifacts.rawConfig,
            };
            if ((_a = rawConfig.serve) === null || _a === void 0 ? void 0 : _a.customServerHandler) {
                const customServerHandler = await utils.loadFromModuleExportExpression(rawConfig.serve.customServerHandler, {
                    defaultExportName: 'default',
                    cwd: baseDir,
                    importFn: utils.defaultImportFn,
                });
                await customServerHandler(serveMeshOptions);
            }
            else {
                await serveMesh(serveMeshOptions, cliParams);
            }
        }
        catch (e) {
            handleFatalError(e, logger);
        }
    })
        .command(cliParams.validateCommand, 'Validates artifacts', builder => { }, async (args) => {
        let destroy;
        try {
            if (!(await utils.pathExists(crossHelpers.path.join(baseDir, cliParams.artifactsDir)))) {
                throw new Error(`You cannot validate artifacts now because you don't have built artifacts yet! You need to build artifacts first with "${cliParams.commandName} build" command!`);
            }
            const store$1 = new store.MeshStore(cliParams.artifactsDir, new store.FsStoreStorageAdapter({
                cwd: baseDir,
                importFn: utils.defaultImportFn,
                fileType: 'ts',
            }), {
                readonly: false,
                validate: true,
            });
            logger.info(`Reading the configuration`);
            const meshConfig = await findAndParseConfig({
                dir: baseDir,
                store: store$1,
                importFn: utils.defaultImportFn,
                ignoreAdditionalResolvers: true,
                artifactsDir: cliParams.artifactsDir,
                configName: cliParams.configName,
            });
            logger = meshConfig.logger;
            logger.info(`Generating the unified schema`);
            const mesh = await runtime.getMesh(meshConfig);
            logger.info(`Artifacts have been validated successfully`);
            destroy = mesh === null || mesh === void 0 ? void 0 : mesh.destroy;
        }
        catch (e) {
            handleFatalError(e, logger);
        }
        if (destroy) {
            destroy();
        }
    })
        .command(cliParams.buildArtifactsCommand, 'Builds artifacts', builder => {
        builder.option('fileType', {
            type: 'string',
            choices: ['json', 'ts'],
            default: 'ts',
        });
    }, async (args) => {
        try {
            const outputDir = crossHelpers.path.join(baseDir, cliParams.artifactsDir);
            logger.info('Cleaning existing artifacts');
            await utils.rmdirs(outputDir);
            const importedModulesSet = new Set();
            const importPromises = [];
            const importFn = (moduleId) => {
                const importPromise = utils.defaultImportFn(moduleId)
                    .catch(e => {
                    if (e.message.includes('getter')) {
                        return e;
                    }
                    else {
                        throw e;
                    }
                })
                    .then(m => {
                    importedModulesSet.add(moduleId);
                    return m;
                });
                importPromises.push(importPromise.catch(() => { }));
                return importPromise;
            };
            await Promise.all(importPromises);
            const store$1 = new store.MeshStore(cliParams.artifactsDir, new store.FsStoreStorageAdapter({
                cwd: baseDir,
                importFn,
                fileType: args.fileType,
            }), {
                readonly: false,
                validate: false,
            });
            logger.info(`Reading the configuration`);
            const meshConfig = await findAndParseConfig({
                dir: baseDir,
                store: store$1,
                importFn,
                ignoreAdditionalResolvers: true,
                artifactsDir: cliParams.artifactsDir,
                configName: cliParams.configName,
            });
            logger = meshConfig.logger;
            logger.info(`Generating the unified schema`);
            const { schema, destroy, rawSources } = await runtime.getMesh(meshConfig);
            await utils.writeFile(crossHelpers.path.join(outputDir, 'schema.graphql'), graphql.printSchema(schema));
            logger.info(`Generating artifacts`);
            await generateTsArtifacts({
                unifiedSchema: schema,
                rawSources,
                mergerType: meshConfig.merger.name,
                documents: meshConfig.documents,
                flattenTypes: false,
                importedModulesSet,
                baseDir,
                meshConfigCode: meshConfig.code,
                logger,
                sdkConfig: meshConfig.config.sdk,
                tsOnly: true,
                codegenConfig: meshConfig.config.codegen,
            }, cliParams);
            logger.info(`Cleanup`);
            destroy();
            logger.info('Done! => ' + outputDir);
        }
        catch (e) {
            handleFatalError(e, logger);
        }
    })
        .command(cliParams.sourceServerCommand + ' <source>', 'Serves specific source in development mode', builder => {
        builder.positional('source', {
            type: 'string',
            requiresArg: true,
        });
    }, async (args) => {
        var _a;
        process$1.env.NODE_ENV = 'development';
        const meshConfig = await findAndParseConfig({
            dir: baseDir,
            artifactsDir: cliParams.artifactsDir,
            configName: cliParams.configName,
        });
        logger = meshConfig.logger;
        const sourceIndex = meshConfig.sources.findIndex(rawSource => rawSource.name === args.source);
        if (sourceIndex === -1) {
            throw new Error(`Source ${args.source} not found`);
        }
        const meshInstance$ = runtime.getMesh({
            ...meshConfig,
            additionalTypeDefs: undefined,
            additionalResolvers: [],
            transforms: [],
            sources: [meshConfig.sources[sourceIndex]],
        });
        const serveMeshOptions = {
            baseDir,
            argsPort: 4000 + sourceIndex + 1,
            getBuiltMesh: () => meshInstance$,
            logger: meshConfig.logger.child('Server'),
            rawConfig: meshConfig.config,
            playgroundTitle: `${args.source} GraphiQL`,
        };
        if ((_a = meshConfig.config.serve) === null || _a === void 0 ? void 0 : _a.customServerHandler) {
            const customServerHandler = await utils.loadFromModuleExportExpression(meshConfig.config.serve.customServerHandler, {
                defaultExportName: 'default',
                cwd: baseDir,
                importFn: utils.defaultImportFn,
            });
            await customServerHandler(serveMeshOptions);
        }
        else {
            await serveMesh(serveMeshOptions, cliParams);
        }
    }).argv;
}

graphqlMesh(DEFAULT_CLI_PARAMS).catch(e => handleFatalError(e, new utils.DefaultLogger(DEFAULT_CLI_PARAMS.initialLoggerPrefix)));
