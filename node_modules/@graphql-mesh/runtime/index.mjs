import { getOperationAST, getNamedType, isLeafType, Kind, TypeInfo, visit, visitWithTypeInfo, print } from 'graphql';
import { DefaultLogger, groupTransforms, applySchemaTransforms, printWithCache, parseWithCache, getInterpolatedStringFactory } from '@graphql-mesh/utils';
import { InMemoryLiveQueryStore } from '@n1ru4l/in-memory-live-query-store';
import { delegateToSchema } from '@graphql-tools/delegate';
import { batchDelegateToSchema } from '@graphql-tools/batch-delegate';
import { WrapQuery } from '@graphql-tools/wrap';
import { memoize1, inspect, AggregateError, isAsyncIterable, mapAsyncIterator, parseSelectionSet, isDocumentNode } from '@graphql-tools/utils';
import { envelop, useSchema, useExtendContext, enableIf, useLogger, useErrorHandler } from '@envelop/core';
import { useLiveQuery } from '@envelop/live-query';
import { compileQuery, isCompiledQuery } from 'graphql-jit';

const MESH_CONTEXT_SYMBOL = Symbol('isMeshContext');
const MESH_API_CONTEXT_SYMBOL = Symbol('isMeshAPIContext');

const memoizedGetOperationType = memoize1((document) => {
    const operationAST = getOperationAST(document, undefined);
    if (!operationAST) {
        throw new Error('Must provide document with a valid operation');
    }
    return operationAST.operation;
});
const memoizedGetEnvelopedFactory = memoize1((plugins) => envelop({ plugins }));
async function getMesh(options) {
    var _a, _b;
    const rawSources = [];
    const { pubsub, cache, logger = new DefaultLogger('ðŸ•¸ï¸'), additionalEnvelopPlugins = [] } = options;
    const getMeshLogger = logger.child('GetMesh');
    getMeshLogger.debug(() => `Getting subschemas from source handlers`);
    let failed = false;
    await Promise.allSettled(options.sources.map(async (apiSource) => {
        const apiName = apiSource.name;
        const sourceLogger = logger.child(apiName);
        sourceLogger.debug(() => `Generating the schema`);
        try {
            const source = await apiSource.handler.getMeshSource();
            sourceLogger.debug(() => `The schema has been generated successfully`);
            let apiSchema = source.schema;
            sourceLogger.debug(() => `Analyzing transforms`);
            let transforms;
            const { wrapTransforms, noWrapTransforms } = groupTransforms(apiSource.transforms);
            if (!(wrapTransforms === null || wrapTransforms === void 0 ? void 0 : wrapTransforms.length) && (noWrapTransforms === null || noWrapTransforms === void 0 ? void 0 : noWrapTransforms.length)) {
                sourceLogger.debug(() => `${noWrapTransforms.length} bare transforms found and applying`);
                apiSchema = applySchemaTransforms(apiSchema, source, null, noWrapTransforms);
            }
            else {
                transforms = apiSource.transforms;
            }
            rawSources.push({
                name: apiName,
                schema: apiSchema,
                executor: source.executor,
                transforms,
                contextVariables: source.contextVariables || [],
                handler: apiSource.handler,
                batch: 'batch' in source ? source.batch : true,
                merge: apiSource.merge,
            });
        }
        catch (e) {
            sourceLogger.error(`Failed to generate the schema ${e.stack || e.message}`);
            failed = true;
        }
    }));
    if (failed) {
        throw new Error(`Schemas couldn't be generated successfully. Check for the logs by running Mesh with DEBUG=1 environmental variable to get more verbose output.`);
    }
    getMeshLogger.debug(() => `Schemas have been generated by the source handlers`);
    getMeshLogger.debug(() => `Merging schemas using the defined merging strategy.`);
    const unifiedSchema = await options.merger.getUnifiedSchema({
        rawSources,
        typeDefs: options.additionalTypeDefs,
        resolvers: options.additionalResolvers,
        transforms: options.transforms,
    });
    const liveQueryEnabled = unifiedSchema.getDirective('live') != null;
    if (!liveQueryEnabled && ((_a = options.liveQueryInvalidations) === null || _a === void 0 ? void 0 : _a.length)) {
        getMeshLogger.warn(`You have to add @live directive to additionalTypeDefs to enable Live Queries
See more at https://www.graphql-mesh.com/docs/recipes/live-queries`);
    }
    const liveQueryInvalidationFactoryMap = new Map();
    getMeshLogger.debug(() => `Building Mesh Context`);
    const meshContext = {
        pubsub,
        cache,
        logger,
        [MESH_CONTEXT_SYMBOL]: true,
    };
    getMeshLogger.debug(() => `Attaching in-context SDK, pubsub, cache and liveQueryStore to the context`);
    const sourceMap = unifiedSchema.extensions.sourceMap;
    await Promise.all(rawSources.map(async (rawSource) => {
        const rawSourceLogger = logger.child(`${rawSource.name}`);
        const rawSourceContext = {
            rawSource,
            [MESH_API_CONTEXT_SYMBOL]: true,
        };
        const transformedSchema = sourceMap.get(rawSource);
        const rootTypes = {
            query: transformedSchema.getQueryType(),
            mutation: transformedSchema.getMutationType(),
            subscription: transformedSchema.getSubscriptionType(),
        };
        rawSourceLogger.debug(() => `Generating In Context SDK`);
        for (const operationType in rootTypes) {
            const rootType = rootTypes[operationType];
            if (rootType) {
                rawSourceContext[rootType.name] = {};
                const rootTypeFieldMap = rootType.getFields();
                for (const fieldName in rootTypeFieldMap) {
                    const rootTypeField = rootTypeFieldMap[fieldName];
                    const inContextSdkLogger = rawSourceLogger.child(`InContextSDK.${rootType.name}.${fieldName}`);
                    const namedReturnType = getNamedType(rootTypeField.type);
                    const shouldHaveSelectionSet = !isLeafType(namedReturnType);
                    rawSourceContext[rootType.name][fieldName] = async ({ root, args, context, info = {
                        fieldName,
                        fieldNodes: [],
                        returnType: namedReturnType,
                        parentType: rootType,
                        path: {
                            typename: rootType.name,
                            key: fieldName,
                            prev: undefined,
                        },
                        schema: transformedSchema,
                        fragments: {},
                        rootValue: root,
                        operation: {
                            kind: Kind.OPERATION_DEFINITION,
                            operation: operationType,
                            selectionSet: {
                                kind: Kind.SELECTION_SET,
                                selections: [],
                            },
                        },
                        variableValues: {},
                        cacheControl: {
                            setCacheHint: () => { },
                            cacheHint: {},
                        },
                    }, selectionSet, key, argsFromKeys, valuesFromResults, }) => {
                        inContextSdkLogger.debug(() => `Called with
- root: ${inspect(root)}
- args: ${inspect(args)}
- key: ${inspect(key)}`);
                        const commonDelegateOptions = {
                            schema: rawSource,
                            rootValue: root,
                            operation: operationType,
                            fieldName,
                            returnType: rootTypeField.type,
                            context,
                            transformedSchema,
                            info,
                        };
                        if (selectionSet) {
                            const selectionSetFactory = normalizeSelectionSetParamOrFactory(selectionSet);
                            const path = [fieldName];
                            const wrapQueryTransform = new WrapQuery(path, selectionSetFactory, identical);
                            commonDelegateOptions.transforms = [wrapQueryTransform];
                        }
                        if (shouldHaveSelectionSet) {
                            let selectionCount = 0;
                            for (const fieldNode of info.fieldNodes) {
                                if (fieldNode.selectionSet != null) {
                                    selectionCount += fieldNode.selectionSet.selections.length;
                                }
                            }
                            if (selectionCount === 0) {
                                if (!selectionSet) {
                                    throw new Error(`You have to provide 'selectionSet' for context.${rawSource.name}.${rootType.name}.${fieldName}`);
                                }
                                commonDelegateOptions.info = {
                                    ...info,
                                    fieldNodes: [
                                        {
                                            ...info.fieldNodes[0],
                                            selectionSet: {
                                                kind: Kind.SELECTION_SET,
                                                selections: [
                                                    {
                                                        kind: Kind.FIELD,
                                                        name: {
                                                            kind: Kind.NAME,
                                                            value: '__typename',
                                                        },
                                                    },
                                                ],
                                            },
                                        },
                                        ...info.fieldNodes.slice(1),
                                    ],
                                };
                            }
                        }
                        if (key && argsFromKeys) {
                            const batchDelegationOptions = {
                                ...commonDelegateOptions,
                                key,
                                argsFromKeys,
                                valuesFromResults,
                            };
                            return batchDelegateToSchema(batchDelegationOptions);
                        }
                        else {
                            const options = {
                                ...commonDelegateOptions,
                                args,
                            };
                            const result = await delegateToSchema(options);
                            if (valuesFromResults) {
                                return valuesFromResults(result);
                            }
                            return result;
                        }
                    };
                }
            }
        }
        meshContext[rawSource.name] = rawSourceContext;
    }));
    const compiledQueries = new Map();
    if ((_b = options.documents) === null || _b === void 0 ? void 0 : _b.length) {
        getMeshLogger.debug(() => `Compiling operation documents`);
        for (const documentSource of options.documents || []) {
            compiledQueries.set(documentSource.rawSDL || printWithCache(documentSource.document), compileQuery(unifiedSchema, documentSource.document || parseWithCache(documentSource.rawSDL)));
        }
    }
    const plugins = [
        useSchema(unifiedSchema),
        useExtendContext(() => meshContext),
        enableIf(liveQueryEnabled, () => {
            var _a;
            getMeshLogger.debug(() => `Creating Live Query Store`);
            const liveQueryStore = new InMemoryLiveQueryStore({
                includeIdentifierExtension: true,
            });
            (_a = options.liveQueryInvalidations) === null || _a === void 0 ? void 0 : _a.forEach(liveQueryInvalidation => {
                const rawInvalidationPaths = liveQueryInvalidation.invalidate;
                const factories = rawInvalidationPaths.map(rawInvalidationPath => getInterpolatedStringFactory(rawInvalidationPath));
                liveQueryInvalidationFactoryMap.set(liveQueryInvalidation.field, factories);
            });
            return useLiveQuery({ liveQueryStore });
        }),
        useLogger({
            logFn: (eventName, args) => logger.child(eventName).debug(() => inspect(args)),
        }),
        useErrorHandler(errors => {
            errors.forEach(error => logger.error(error.stack || error.message));
        }),
        {
            onParse({ setParseFn }) {
                setParseFn(parseWithCache);
            },
            onValidate({ params, setResult }) {
                const sdl = printWithCache(params.documentAST).trim();
                if (compiledQueries.has(sdl)) {
                    setResult([]);
                }
            },
            onSubscribe({ args: subscriptionArgs, setSubscribeFn }) {
                const sdl = printWithCache(subscriptionArgs.document);
                const cacheKey = `compiled_${sdl}`;
                const compiledQuery = compiledQueries.get(cacheKey);
                if (compiledQuery != null) {
                    logger.debug(() => {
                        var _a, _b;
                        return `Persisted compiled query found: ${(_b = (_a = getOperationAST(subscriptionArgs.document, subscriptionArgs.operationName)) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.value}`;
                    });
                    if (isCompiledQuery(compiledQuery)) {
                        setSubscribeFn(() => compiledQuery.subscribe(subscriptionArgs.rootValue, subscriptionArgs.contextValue, subscriptionArgs.variableValues));
                    }
                }
            },
            onExecute({ args: executionArgs, setResultAndStopExecution, setExecuteFn }) {
                const sdl = printWithCache(executionArgs.document);
                const cacheKey = `compiled_${sdl}`;
                const compiledQuery = compiledQueries.get(cacheKey);
                if (compiledQuery != null) {
                    logger.debug(() => {
                        var _a, _b;
                        return `Persisted compiled query found: ${(_b = (_a = getOperationAST(executionArgs.document, executionArgs.operationName)) === null || _a === void 0 ? void 0 : _a.name) === null || _b === void 0 ? void 0 : _b.value}`;
                    });
                    if (isCompiledQuery(compiledQuery)) {
                        setExecuteFn(() => compiledQuery.query(executionArgs.rootValue, executionArgs.contextValue, executionArgs.variableValues));
                    }
                    else {
                        setResultAndStopExecution(compiledQuery);
                    }
                }
                if (liveQueryEnabled) {
                    return {
                        async onExecuteDone({ args: executionArgs, result }) {
                            const { schema, document, operationName, rootValue, contextValue } = executionArgs;
                            const operationAST = getOperationAST(document, operationName);
                            if (!operationAST) {
                                throw new Error(`Operation couldn't be found`);
                            }
                            const typeInfo = new TypeInfo(schema);
                            visit(operationAST, visitWithTypeInfo(typeInfo, {
                                Field: () => {
                                    const parentType = typeInfo.getParentType();
                                    const fieldDef = typeInfo.getFieldDef();
                                    const path = `${parentType.name}.${fieldDef.name}`;
                                    if (liveQueryInvalidationFactoryMap.has(path)) {
                                        const invalidationPathFactories = liveQueryInvalidationFactoryMap.get(path);
                                        const invalidationPaths = invalidationPathFactories.map(invalidationPathFactory => invalidationPathFactory({ root: rootValue, context: contextValue, env: process.env, result }));
                                        executionArgs.contextValue.liveQueryStore
                                            .invalidate(invalidationPaths)
                                            .catch((e) => logger.warn(`Invalidation failed for ${path}: ${e.message}`));
                                    }
                                },
                            }));
                        },
                    };
                }
                return {};
            },
        },
        ...additionalEnvelopPlugins,
    ];
    const EMPTY_ROOT_VALUE = {};
    const EMPTY_CONTEXT_VALUE = {};
    const EMPTY_VARIABLES_VALUE = {};
    async function meshExecute(documentOrSDL, variableValues = EMPTY_VARIABLES_VALUE, contextValue = EMPTY_CONTEXT_VALUE, rootValue = EMPTY_ROOT_VALUE, operationName) {
        const getEnveloped = memoizedGetEnvelopedFactory(plugins);
        const { execute, contextFactory, parse } = getEnveloped(contextValue);
        return execute({
            document: typeof documentOrSDL === 'string' ? parse(documentOrSDL) : documentOrSDL,
            contextValue: await contextFactory(),
            rootValue,
            variableValues: variableValues,
            schema: unifiedSchema,
            operationName,
        });
    }
    async function meshSubscribe(documentOrSDL, variableValues = EMPTY_VARIABLES_VALUE, contextValue = EMPTY_CONTEXT_VALUE, rootValue = EMPTY_ROOT_VALUE, operationName) {
        const getEnveloped = memoizedGetEnvelopedFactory(plugins);
        const { subscribe, contextFactory, parse } = getEnveloped(contextValue);
        return subscribe({
            document: typeof documentOrSDL === 'string' ? parse(documentOrSDL) : documentOrSDL,
            contextValue: await contextFactory(),
            rootValue,
            variableValues: variableValues,
            schema: unifiedSchema,
            operationName,
        });
    }
    function sdkRequesterFactory(globalContext) {
        return async function meshSdkRequester(document, variables, contextValue) {
            if (memoizedGetOperationType(document) === 'subscription') {
                const result = await meshSubscribe(document, variables, {
                    ...globalContext,
                    ...contextValue,
                });
                if ('errors' in result) {
                    return new AggregateError(result.errors);
                }
                if (isAsyncIterable(result)) {
                    return mapAsyncIterator(result, result => result.data);
                }
                return result.data;
            }
            else {
                const result = await meshExecute(document, variables, {
                    ...globalContext,
                    ...contextValue,
                });
                if ('errors' in result) {
                    return new AggregateError(result.errors);
                }
                return result.data;
            }
        };
    }
    return {
        execute: meshExecute,
        subscribe: meshSubscribe,
        schema: unifiedSchema,
        rawSources,
        cache,
        pubsub,
        destroy: () => pubsub.publish('destroy', undefined),
        logger,
        meshContext: meshContext,
        plugins,
        get getEnveloped() {
            return memoizedGetEnvelopedFactory(plugins);
        },
        sdkRequesterFactory,
    };
}
function normalizeSelectionSetParam(selectionSetParam) {
    if (typeof selectionSetParam === 'string') {
        return parseSelectionSet(selectionSetParam);
    }
    if (isDocumentNode(selectionSetParam)) {
        return parseSelectionSet(print(selectionSetParam));
    }
    return selectionSetParam;
}
function normalizeSelectionSetParamOrFactory(selectionSetParamOrFactory) {
    return function getSelectionSet(subtree) {
        if (typeof selectionSetParamOrFactory === 'function') {
            const selectionSetParam = selectionSetParamOrFactory(subtree);
            return normalizeSelectionSetParam(selectionSetParam);
        }
        else {
            return normalizeSelectionSetParam(selectionSetParamOrFactory);
        }
    };
}
function identical(val) {
    return val;
}

export { getMesh };
