import { fetchFactory } from 'fetchache';
import { fetch, Request, Response } from 'cross-undici-fetch';
import isUrl from 'is-url';
export { default as isUrl } from 'is-url';
import { load, DEFAULT_SCHEMA, Type } from 'js-yaml';
import { path, fs } from '@graphql-mesh/cross-helpers';
import { memoize1, getResolversFromSchema, getOperationASTFromRequest, parseSelectionSet, observableToAsyncIterable } from '@graphql-tools/utils';
export { AggregateError } from '@graphql-tools/utils';
import { Interpolator } from '@ardatan/string-interpolation';
import { format } from 'date-fns';
import objectHash from 'object-hash';
import flatstr from 'flatstr';
import lru from 'tiny-lru';
import { compileQuery, isCompiledQuery } from 'graphql-jit';
import { parse, print, isAbstractType, getNamedType, Kind } from 'graphql';
import { withFilter } from 'graphql-subscriptions';
import _ from 'lodash';
import chalk from 'chalk';
import fileUriToPath from 'file-uri-to-path';

async function defaultImportFn(path) {
    let module = await import(path);
    if (module.default != null) {
        module = module.default;
    }
    if (typeof module === 'object' && module != null) {
        const prototypeOfObject = Object.getPrototypeOf(module);
        if (prototypeOfObject == null || prototypeOfObject === Object.prototype) {
            const normalizedVal = {};
            for (const key in module) {
                normalizedVal[key] = module[key];
            }
            return normalizedVal;
        }
    }
    return module;
}

/* eslint-disable @typescript-eslint/return-await */
function loadFromModuleExportExpression(expression, options) {
    if (typeof expression !== 'string') {
        return Promise.resolve(expression);
    }
    const { defaultExportName, cwd, importFn = defaultImportFn } = options || {};
    const [modulePath, exportName = defaultExportName] = expression.split('#');
    return tryImport(modulePath, cwd, importFn).then(mod => mod[exportName] || (mod.default && mod.default[exportName]) || mod.default || mod);
}
function tryImport(modulePath, cwd, importFn) {
    return importFn(modulePath).catch((e1) => {
        if (!path.isAbsolute(modulePath)) {
            const absoluteModulePath = path.isAbsolute(modulePath) ? modulePath : path.join(cwd, modulePath);
            return importFn(absoluteModulePath);
        }
    });
}

const getCachedFetch = memoize1(function getCachedFetch(cache) {
    return fetchFactory({
        fetch: fetch,
        Request,
        Response,
        cache,
    });
});
async function readFileOrUrl(filePathOrUrl, config) {
    var _a, _b;
    if (isUrl(filePathOrUrl)) {
        (_a = config === null || config === void 0 ? void 0 : config.logger) === null || _a === void 0 ? void 0 : _a.debug(() => `Fetching ${filePathOrUrl} via HTTP`);
        return readUrl(filePathOrUrl, config);
    }
    else {
        (_b = config === null || config === void 0 ? void 0 : config.logger) === null || _b === void 0 ? void 0 : _b.debug(() => `Reading ${filePathOrUrl} from the file system`);
        return readFile(filePathOrUrl, config);
    }
}
function getSchema(filepath, logger) {
    return DEFAULT_SCHEMA.extend([
        new Type('!include', {
            kind: 'scalar',
            resolve(path) {
                return typeof path === 'string';
            },
            construct(path$1) {
                const newCwd = path.dirname(filepath);
                const absoluteFilePath = path.isAbsolute(path$1) ? path$1 : path.resolve(newCwd, path$1);
                const content = fs.readFileSync(absoluteFilePath, 'utf8');
                return loadYaml(absoluteFilePath, content, logger);
            },
        }),
        new Type('!includes', {
            kind: 'scalar',
            resolve(path) {
                return typeof path === 'string';
            },
            construct(path$1) {
                const newCwd = path.dirname(filepath);
                const absoluteDirPath = path.isAbsolute(path$1) ? path$1 : path.resolve(newCwd, path$1);
                const files = fs.readdirSync(absoluteDirPath);
                return files.map(filePath => {
                    const absoluteFilePath = path.resolve(absoluteDirPath, filePath);
                    const fileContent = fs.readFileSync(absoluteFilePath, 'utf8');
                    return loadYaml(absoluteFilePath, fileContent, logger);
                });
            },
        }),
    ]);
}
function loadYaml(filepath, content, logger) {
    return load(content, {
        filename: filepath,
        schema: getSchema(filepath, logger),
        onWarning(warning) {
            logger === null || logger === void 0 ? void 0 : logger.warn(`${filepath}: ${warning.message}\n${warning.stack}`);
        },
    });
}
async function readFile(fileExpression, config) {
    const { allowUnknownExtensions, cwd, fallbackFormat, importFn = defaultImportFn } = config || {};
    const [filePath] = fileExpression.split('#');
    if (/js$/.test(filePath) || /ts$/.test(filePath)) {
        return loadFromModuleExportExpression(fileExpression, {
            cwd,
            importFn,
            defaultExportName: 'default',
        });
    }
    const actualPath = path.isAbsolute(filePath) ? filePath : path.resolve(cwd || process.cwd(), filePath);
    const rawResult = await fs.promises.readFile(actualPath, 'utf-8');
    if (/json$/.test(actualPath)) {
        return JSON.parse(rawResult);
    }
    if (/yaml$/.test(actualPath) || /yml$/.test(actualPath)) {
        return loadYaml(actualPath, rawResult, config === null || config === void 0 ? void 0 : config.logger);
    }
    else if (fallbackFormat) {
        switch (fallbackFormat) {
            case 'json':
                return JSON.parse(rawResult);
            case 'yaml':
                return loadYaml(actualPath, rawResult, config === null || config === void 0 ? void 0 : config.logger);
            case 'ts':
            case 'js':
                return importFn(actualPath);
        }
    }
    else if (!allowUnknownExtensions) {
        throw new Error(`Failed to parse JSON/YAML. Ensure file '${filePath}' has ` +
            `the correct extension (i.e. '.json', '.yaml', or '.yml).`);
    }
    return rawResult;
}
async function readUrl(path, config) {
    var _a, _b;
    const { allowUnknownExtensions, fallbackFormat } = config || {};
    const fetch$1 = (config === null || config === void 0 ? void 0 : config.fetch) || fetch;
    config.headers = config.headers || {};
    const response = await fetch$1(path, config);
    const contentType = ((_a = response.headers) === null || _a === void 0 ? void 0 : _a.get('content-type')) || '';
    const responseText = await response.text();
    (_b = config === null || config === void 0 ? void 0 : config.logger) === null || _b === void 0 ? void 0 : _b.debug(() => `${path} returned "${(responseText === null || responseText === void 0 ? void 0 : responseText.slice(0, 100)) + '...'}"`);
    if (/json$/.test(path) || contentType.startsWith('application/json') || fallbackFormat === 'json') {
        return JSON.parse(responseText);
    }
    else if (/yaml$/.test(path) ||
        /yml$/.test(path) ||
        contentType.includes('yaml') ||
        contentType.includes('yml') ||
        fallbackFormat === 'yaml') {
        return loadYaml(path, responseText, config === null || config === void 0 ? void 0 : config.logger);
    }
    else if (!allowUnknownExtensions) {
        throw new Error(`Failed to parse JSON/YAML. Ensure URL '${path}' has ` +
            `the correct extension (i.e. '.json', '.yaml', or '.yml) or mime type in the response headers.`);
    }
    return responseText;
}

function hashObject(value) {
    return objectHash(value, { ignoreUnknown: true }).toString();
}

const stringInterpolator = new Interpolator({
    delimiter: ['{', '}'],
});
stringInterpolator.addAlias('typeName', 'info.parentType.name');
stringInterpolator.addAlias('type', 'info.parentType.name');
stringInterpolator.addAlias('parentType', 'info.parentType.name');
stringInterpolator.addAlias('fieldName', 'info.fieldName');
stringInterpolator.registerModifier('date', (formatStr) => format(new Date(), formatStr));
stringInterpolator.registerModifier('hash', (value) => hashObject(value));

function getInterpolationKeys(...interpolationStrings) {
    return interpolationStrings.reduce((keys, str) => [...keys, ...(str ? stringInterpolator.parseRules(str).map((match) => match.key) : [])], []);
}
function parseInterpolationStrings(interpolationStrings, argTypeMap) {
    const interpolationKeys = getInterpolationKeys(...interpolationStrings);
    const args = {};
    const contextVariables = [];
    for (const interpolationKey of interpolationKeys) {
        const interpolationKeyParts = interpolationKey.split('.');
        const varName = interpolationKeyParts[interpolationKeyParts.length - 1];
        if (interpolationKeyParts[0] === 'args') {
            const argType = argTypeMap && varName in argTypeMap ? argTypeMap[varName] : 'ID';
            args[varName] = {
                type: argType,
            };
        }
        else if (interpolationKeyParts[0] === 'context') {
            contextVariables.push(varName);
        }
    }
    return {
        args,
        contextVariables,
    };
}
function getInterpolatedStringFactory(nonInterpolatedString) {
    return resolverData => stringInterpolator.parse(nonInterpolatedString, resolverData);
}
function getInterpolatedHeadersFactory(nonInterpolatedHeaders = {}) {
    return resolverData => {
        const headers = {};
        for (const headerName in nonInterpolatedHeaders) {
            const headerValue = nonInterpolatedHeaders[headerName];
            if (headerValue) {
                headers[headerName.toLowerCase()] = stringInterpolator.parse(headerValue, resolverData);
            }
        }
        return headers;
    };
}
function getHeadersObject(headers) {
    const headersObj = {};
    headers.forEach((value, key) => {
        headersObj[key] = value;
    });
    return headersObj;
}

function withCancel(asyncIterable, onCancel) {
    return new Proxy(asyncIterable, {
        get(asyncIterable, prop) {
            var _a;
            if (prop === Symbol.asyncIterator) {
                return function getIteratorWithCancel() {
                    const asyncIterator = asyncIterable[Symbol.asyncIterator]();
                    return {
                        next: asyncIterator.next ? (...args) => asyncIterator.next(...args) : undefined,
                        return: async (...args) => {
                            onCancel();
                            if (asyncIterator.return) {
                                return asyncIterator.return(...args);
                            }
                            return {
                                value: undefined,
                                done: true,
                            };
                        },
                        throw: asyncIterator.throw ? (...args) => asyncIterator.throw(...args) : undefined,
                    };
                };
            }
            return (_a = asyncIterable[prop]) === null || _a === void 0 ? void 0 : _a.bind(asyncIterable);
        },
    });
}

function extractResolvers(schema) {
    const allResolvers = getResolversFromSchema(schema);
    const filteredResolvers = {};
    for (const prop in allResolvers) {
        if (!prop.startsWith('_')) {
            filteredResolvers[prop] = allResolvers[prop];
        }
        if (typeof filteredResolvers === 'object') {
            for (const fieldName in filteredResolvers[prop]) {
                if (!prop.startsWith('_resolveType')) {
                    filteredResolvers[prop][fieldName] = allResolvers[prop][fieldName];
                }
            }
        }
    }
    return filteredResolvers;
}

function groupTransforms(transforms) {
    const wrapTransforms = [];
    const noWrapTransforms = [];
    transforms === null || transforms === void 0 ? void 0 : transforms.forEach(transform => {
        if (transform.noWrap) {
            noWrapTransforms.push(transform);
        }
        else {
            wrapTransforms.push(transform);
        }
    });
    return { wrapTransforms, noWrapTransforms };
}

function applySchemaTransforms(originalWrappingSchema, subschemaConfig, transformedSchema, transforms) {
    return transforms.reduce((schema, transform) => 'transformSchema' in transform ? transform.transformSchema(schema, subschemaConfig, transformedSchema) : schema, originalWrappingSchema);
}
function applyRequestTransforms(originalRequest, delegationContext, transformationContext, transforms) {
    transformationContext.contextMap = transformationContext.contextMap || new WeakMap();
    const contextMap = transformationContext.contextMap;
    transforms === null || transforms === void 0 ? void 0 : transforms.forEach(transform => {
        if (!contextMap.has(transform)) {
            contextMap.set(transform, {
                nextIndex: 0,
                paths: {},
            });
        }
    });
    return transforms.reduceRight((request, transform) => 'transformRequest' in transform
        ? transform.transformRequest(request, delegationContext, contextMap.get(transform))
        : request, originalRequest);
}
function applyResultTransforms(originalResult, delegationContext, transformationContext, transforms) {
    const contextMap = transformationContext.contextMap;
    return transforms.reduce((result, transform) => 'transformResult' in transform
        ? transform.transformResult(result, delegationContext, contextMap.get(transform))
        : result, originalResult);
}

function flatString(str) {
    return flatstr(str);
}
function jsonFlatStringify(data, replacer, space) {
    return flatString(JSON.stringify(data, replacer, space));
}

async function pathExists(path) {
    if (!path) {
        return false;
    }
    try {
        await fs.promises.stat(path);
        return true;
    }
    catch (e) {
        if (e.toString().includes('ENOENT')) {
            return false;
        }
        else {
            throw e;
        }
    }
}
function writeJSON(path, data, replacer, space) {
    const stringified = jsonFlatStringify(data, replacer, space);
    return writeFile(path, stringified, 'utf-8');
}
const writeFile = async (path$1, ...args) => {
    if (typeof path$1 === 'string') {
        const containingDir = path.dirname(path$1);
        if (!(await pathExists(containingDir))) {
            await mkdir(containingDir);
        }
    }
    return fs.promises.writeFile(path$1, ...args);
};
async function mkdir(path, options = { recursive: true }) {
    const ifExists = await pathExists(path);
    if (!ifExists) {
        await fs.promises.mkdir(path, options);
    }
}
async function rmdirs(dir) {
    if (await pathExists(dir)) {
        const entries = await fs.promises.readdir(dir, { withFileTypes: true });
        const results = await Promise.allSettled(entries.map(entry => {
            const fullPath = path.join(dir, entry.name);
            if (entry.isDirectory()) {
                return rmdirs(fullPath);
            }
            else {
                return fs.promises.unlink(fullPath);
            }
        }));
        for (const result of results) {
            if (result.status === 'rejected' && result.reason.code !== 'ENOENT') {
                throw result.reason;
            }
        }
        await fs.promises.rmdir(dir);
    }
}

function createLruCache(max, ttl) {
    return lru(max, ttl);
}

const parseCache = createLruCache(1000, 3600);
const printCache = createLruCache(1000, 3600);
function parseWithCache(sdl) {
    const trimmedSdl = sdl.trim();
    let document = parseCache.get(trimmedSdl);
    if (!document) {
        document = parse(trimmedSdl, { noLocation: true });
        parseCache.set(trimmedSdl, document);
        printCache.set(JSON.stringify(document), trimmedSdl);
    }
    return document;
}
const printWithCache = memoize1(function printWithCache(document) {
    const stringifedDocumentJson = JSON.stringify(document);
    let sdl = printCache.get(stringifedDocumentJson);
    if (!sdl) {
        sdl = print(document).trim();
        printCache.set(stringifedDocumentJson, sdl);
        parseCache.set(sdl, document);
    }
    return sdl;
});
function gql([sdl], ...args) {
    let result = sdl;
    for (const arg of args || []) {
        if (typeof arg === 'string') {
            result += arg;
        }
        else {
            result += printWithCache(arg);
        }
    }
    return parseWithCache(result);
}

const getLruCacheForSchema = memoize1(function getLruCacheForSchema(schema) {
    return createLruCache(1000, 3600);
});
function jitExecutorFactory(schema, prefix, logger) {
    const lruCache = getLruCacheForSchema(schema);
    return function jitExecutor(request) {
        const { document, variables, context, operationName, rootValue } = request;
        const documentStr = printWithCache(document);
        logger.debug(() => `Executing ${documentStr}`);
        const cacheKey = [prefix, documentStr, operationName].join('_');
        let compiledQueryFn = lruCache.get(cacheKey);
        if (!compiledQueryFn) {
            logger.debug(() => `Compiling ${documentStr}`);
            const compiledQuery = compileQuery(schema, document, operationName);
            if (isCompiledQuery(compiledQuery)) {
                const { operation } = getOperationASTFromRequest(request);
                if (operation === 'subscription') {
                    compiledQueryFn = compiledQuery.subscribe.bind(compiledQuery);
                }
                else {
                    compiledQueryFn = compiledQuery.query.bind(compiledQuery);
                }
            }
            else {
                compiledQueryFn = () => compiledQuery;
            }
            lruCache.set(cacheKey, compiledQueryFn);
        }
        else {
            logger.debug(() => `Compiled version found for ${documentStr}`);
        }
        return compiledQueryFn(rootValue, context, variables);
    };
}

const reservedNames = ['Query', 'Mutation', 'Subscription'];
const KNOWN_CHARACTERS = {
    '+': 'PLUS',
    '-': 'MINUS',
    '>': 'GREATER_THAN',
    '<': 'LESS_THAN',
    '=': 'EQUALS',
    '&': 'AMPERSAND',
    '|': 'PIPE',
    '@': 'AT',
    '*': 'STAR',
    ':': 'COLON',
    '{': 'LEFT_CURLY_BRACE',
    '}': 'RIGHT_CURLY_BRACE',
    '[': 'LEFT_SQUARE_BRACE',
    ']': 'RIGHT_SQUARE_BRACE',
    ',': 'COMMA',
    '%': 'PERCENT',
    $: 'DOLLAR',
    '#': 'POUND',
    '^': 'CARET',
    '~': 'TILDE',
    '?': 'QUESTION_MARK',
    '!': 'EXCLAMATION_MARK',
    '"': 'QUOTATION_MARK',
    "'": 'SINGLE_QUOTE',
    '\\': 'BACKSLASH',
    '/': 'SLASH',
    '.': 'DOT',
    '`': 'BACKTICK',
    ';': 'SEMICOLON',
    '(': 'LEFT_PARENTHESIS',
    ')': 'RIGHT_PARENTHESIS',
};
function getKnownCharacterOrCharCode(ch) {
    return KNOWN_CHARACTERS[ch] || ch.charCodeAt(0).toString();
}
function sanitizeNameForGraphQL(unsafeName) {
    let sanitizedName = unsafeName.trim();
    if (!isNaN(parseInt(sanitizedName))) {
        if (sanitizedName.startsWith('-')) {
            sanitizedName = sanitizedName.replace('-', 'NEGATIVE_');
        }
        else {
            sanitizedName = '_' + sanitizedName;
        }
    }
    if (!/^[_a-zA-Z0-9]*$/.test(sanitizedName)) {
        const unsanitizedName = sanitizedName;
        sanitizedName = '';
        for (const ch of unsanitizedName) {
            if (/^[_a-zA-Z0-9]$/.test(ch)) {
                sanitizedName += ch;
            }
            else if (ch === ' ' || ch === '-') {
                sanitizedName += '_';
            }
            else {
                sanitizedName += `_${getKnownCharacterOrCharCode(ch)}_`;
            }
        }
    }
    // Names cannot start with __
    if (sanitizedName.startsWith('__')) {
        sanitizedName = sanitizedName.replace('__', '_0');
    }
    if (reservedNames.includes(sanitizedName)) {
        sanitizedName += '_';
    }
    return sanitizedName;
}

function getTypeByPath(type, path) {
    if ('ofType' in type) {
        return getTypeByPath(type.ofType, path);
    }
    if (path.length === 0) {
        return type;
    }
    if (!('getFields' in type)) {
        throw new Error(`${type} cannot have a path ${path.join('.')}`);
    }
    const fieldMap = type.getFields();
    const currentFieldName = path[0];
    // Might be an index of an array
    if (!Number.isNaN(parseInt(currentFieldName))) {
        return getTypeByPath(type, path.slice(1));
    }
    const field = fieldMap[currentFieldName];
    if (!(field === null || field === void 0 ? void 0 : field.type)) {
        throw new Error(`${type}.${currentFieldName} is not a valid field.`);
    }
    return getTypeByPath(field.type, path.slice(1));
}
function generateSelectionSetFactory(schema, additionalResolver) {
    if (additionalResolver.sourceSelectionSet) {
        return () => parseSelectionSet(additionalResolver.sourceSelectionSet);
        // If result path provided without a selectionSet
    }
    else if (additionalResolver.result) {
        const resultPath = _.toPath(additionalResolver.result);
        let abstractResultType;
        const sourceType = schema.getType(additionalResolver.sourceTypeName);
        const sourceTypeFields = sourceType.getFields();
        const sourceField = sourceTypeFields[additionalResolver.sourceFieldName];
        const resultFieldType = getTypeByPath(sourceField.type, resultPath);
        if (isAbstractType(resultFieldType)) {
            if (additionalResolver.resultType) {
                abstractResultType = additionalResolver.resultType;
            }
            else {
                const targetType = schema.getType(additionalResolver.targetTypeName);
                const targetTypeFields = targetType.getFields();
                const targetField = targetTypeFields[additionalResolver.targetFieldName];
                const targetFieldType = getNamedType(targetField.type);
                abstractResultType = targetFieldType === null || targetFieldType === void 0 ? void 0 : targetFieldType.name;
            }
            const possibleTypes = schema.getPossibleTypes(resultFieldType);
            if (!possibleTypes.some(possibleType => possibleType.name === abstractResultType)) {
                throw new Error(`${additionalResolver.sourceTypeName}.${additionalResolver.sourceFieldName}.${resultPath.join('.')} doesn't implement ${abstractResultType}. Please specify one of the following types as "returnType"; ${possibleTypes.map(t => t.name)}`);
            }
        }
        return (subtree) => {
            let finalSelectionSet = subtree;
            let isLastResult = true;
            const resultPathReversed = [...resultPath].reverse();
            for (const pathElem of resultPathReversed) {
                // Ensure the path elem is not array index
                if (Number.isNaN(parseInt(pathElem))) {
                    if (isLastResult && abstractResultType) {
                        finalSelectionSet = {
                            kind: Kind.SELECTION_SET,
                            selections: [
                                {
                                    kind: Kind.INLINE_FRAGMENT,
                                    typeCondition: {
                                        kind: Kind.NAMED_TYPE,
                                        name: {
                                            kind: Kind.NAME,
                                            value: abstractResultType,
                                        },
                                    },
                                    selectionSet: finalSelectionSet,
                                },
                            ],
                        };
                    }
                    finalSelectionSet = {
                        kind: Kind.SELECTION_SET,
                        selections: [
                            {
                                // we create a wrapping AST Field
                                kind: Kind.FIELD,
                                name: {
                                    kind: Kind.NAME,
                                    value: pathElem,
                                },
                                // Inside the field selection
                                selectionSet: finalSelectionSet,
                            },
                        ],
                    };
                    isLastResult = false;
                }
            }
            return finalSelectionSet;
        };
    }
    return undefined;
}
function generateValuesFromResults(resultExpression) {
    return function valuesFromResults(result) {
        if (Array.isArray(result)) {
            return result.map(valuesFromResults);
        }
        return _.get(result, resultExpression);
    };
}
function resolveAdditionalResolvers(baseDir, additionalResolvers, importFn, pubsub) {
    return Promise.all((additionalResolvers || []).map(async (additionalResolver) => {
        if (typeof additionalResolver === 'string') {
            const resolvers = await loadFromModuleExportExpression(additionalResolver, {
                cwd: baseDir,
                defaultExportName: 'resolvers',
                importFn,
            });
            if (!resolvers) {
                console.warn(`Unable to load resolvers from file: ${additionalResolver}`);
                return {};
            }
            return resolvers;
        }
        else {
            const baseOptions = {};
            if (additionalResolver.result) {
                baseOptions.valuesFromResults = generateValuesFromResults(additionalResolver.result);
            }
            if ('pubsubTopic' in additionalResolver) {
                return {
                    [additionalResolver.targetTypeName]: {
                        [additionalResolver.targetFieldName]: {
                            subscribe: withFilter((root, args, context, info) => {
                                const resolverData = { root, args, context, info, env: process.env };
                                const topic = stringInterpolator.parse(additionalResolver.pubsubTopic, resolverData);
                                return pubsub.asyncIterator(topic);
                            }, (root, args, context, info) => {
                                return additionalResolver.filterBy ? eval(additionalResolver.filterBy) : true;
                            }),
                            resolve: (payload) => {
                                if (baseOptions.valuesFromResults) {
                                    return baseOptions.valuesFromResults(payload);
                                }
                                return payload;
                            },
                        },
                    },
                };
            }
            else if ('keysArg' in additionalResolver) {
                return {
                    [additionalResolver.targetTypeName]: {
                        [additionalResolver.targetFieldName]: {
                            selectionSet: additionalResolver.requiredSelectionSet || `{ ${additionalResolver.keyField} }`,
                            resolve: async (root, args, context, info) => {
                                if (!baseOptions.selectionSet) {
                                    baseOptions.selectionSet = generateSelectionSetFactory(info.schema, additionalResolver);
                                }
                                const resolverData = { root, args, context, info, env: process.env };
                                const targetArgs = {};
                                for (const argPath in additionalResolver.additionalArgs || {}) {
                                    _.set(targetArgs, argPath, stringInterpolator.parse(additionalResolver.additionalArgs[argPath], resolverData));
                                }
                                const options = {
                                    ...baseOptions,
                                    root,
                                    context,
                                    info,
                                    argsFromKeys: (keys) => {
                                        const args = {};
                                        _.set(args, additionalResolver.keysArg, keys);
                                        Object.assign(args, targetArgs);
                                        return args;
                                    },
                                    key: _.get(root, additionalResolver.keyField),
                                };
                                return context[additionalResolver.sourceName][additionalResolver.sourceTypeName][additionalResolver.sourceFieldName](options);
                            },
                        },
                    },
                };
            }
            else if ('targetTypeName' in additionalResolver) {
                return {
                    [additionalResolver.targetTypeName]: {
                        [additionalResolver.targetFieldName]: {
                            selectionSet: additionalResolver.requiredSelectionSet,
                            resolve: (root, args, context, info) => {
                                // Assert source exists
                                if (!context[additionalResolver.sourceName]) {
                                    throw new Error(`No source found named "${additionalResolver.sourceName}"`);
                                }
                                if (!context[additionalResolver.sourceName][additionalResolver.sourceTypeName]) {
                                    throw new Error(`No root type found named "${additionalResolver.sourceTypeName}" exists in the source ${additionalResolver.sourceName}\n` +
                                        `It should be one of the following; ${Object.keys(context[additionalResolver.sourceName]).join(',')})}}`);
                                }
                                if (!context[additionalResolver.sourceName][additionalResolver.sourceTypeName][additionalResolver.sourceFieldName]) {
                                    throw new Error(`No field named "${additionalResolver.sourceFieldName}" exists in the type ${additionalResolver.sourceTypeName} from the source ${additionalResolver.sourceName}`);
                                }
                                if (!baseOptions.selectionSet) {
                                    baseOptions.selectionSet = generateSelectionSetFactory(info.schema, additionalResolver);
                                }
                                const resolverData = { root, args, context, info, env: process.env };
                                const targetArgs = {};
                                for (const argPath in additionalResolver.sourceArgs) {
                                    _.set(targetArgs, argPath, stringInterpolator.parse(additionalResolver.sourceArgs[argPath].toString(), resolverData));
                                }
                                const options = {
                                    ...baseOptions,
                                    root,
                                    args: targetArgs,
                                    context,
                                    info,
                                };
                                return context[additionalResolver.sourceName][additionalResolver.sourceTypeName][additionalResolver.sourceFieldName](options);
                            },
                        },
                    },
                };
            }
            else {
                return additionalResolver;
            }
        }
    }));
}

const warnColor = chalk.keyword(`orange`);
const infoColor = chalk.cyan;
const errorColor = chalk.red;
const debugColor = chalk.magenta;
const titleBold = chalk.bold;
function handleLazyMessage(lazyMessage) {
    if (typeof lazyMessage === 'function') {
        return lazyMessage();
    }
    return lazyMessage;
}
class DefaultLogger {
    constructor(name) {
        this.name = name;
    }
    log(message) {
        const finalMessage = this.name ? `${titleBold(this.name)}: ${message}` : message;
        return console.log(finalMessage);
    }
    warn(message) {
        return this.log(warnColor(message));
    }
    info(message) {
        return this.log(infoColor(message));
    }
    error(message) {
        return this.log(errorColor(message));
    }
    debug(lazyMessage) {
        if ((process.env.DEBUG && process.env.DEBUG === '1') || this.name.includes(process.env.DEBUG)) {
            const message = handleLazyMessage(lazyMessage);
            return this.log(debugColor(message));
        }
    }
    child(name) {
        return new DefaultLogger(this.name ? `${this.name} - ${name}` : name);
    }
}

class PubSub {
    constructor() {
        this.subIdListenerMap = new Map();
        this.listenerEventMap = new Map();
        this.eventNameListenersMap = new Map();
    }
    async publish(triggerName, detail) {
        const eventNameListeners = this.eventNameListenersMap.get(triggerName);
        if (eventNameListeners) {
            Promise.allSettled([...eventNameListeners].map(listener => listener(detail))).catch(e => console.error(e));
        }
    }
    async subscribe(triggerName, onMessage) {
        let eventNameListeners = this.eventNameListenersMap.get(triggerName);
        if (!eventNameListeners) {
            eventNameListeners = new Set();
            this.eventNameListenersMap.set(triggerName, eventNameListeners);
        }
        const subId = Date.now();
        eventNameListeners.add(onMessage);
        this.subIdListenerMap.set(subId, onMessage);
        this.listenerEventMap.set(onMessage, triggerName);
        return subId;
    }
    unsubscribe(subId) {
        const listener = this.subIdListenerMap.get(subId);
        if (listener) {
            this.subIdListenerMap.delete(subId);
            const eventName = this.listenerEventMap.get(listener);
            if (eventName) {
                const eventNameListeners = this.eventNameListenersMap.get(eventName);
                if (eventNameListeners) {
                    eventNameListeners.delete(listener);
                }
            }
        }
        this.listenerEventMap.delete(listener);
    }
    asyncIterator(triggerName) {
        return observableToAsyncIterable({
            subscribe: observer => {
                const subId$ = this.subscribe(triggerName, data => observer.next(data));
                return {
                    unsubscribe: () => subId$.then(subId => this.unsubscribe(subId)),
                };
            },
        });
    }
}

function fileURLToPath(url) {
    if (url.startsWith('file://')) {
        return fileUriToPath(url);
    }
    return url;
}

export { DefaultLogger, PubSub, applyRequestTransforms, applyResultTransforms, applySchemaTransforms, createLruCache, defaultImportFn, extractResolvers, fileURLToPath, flatString, getCachedFetch, getHeadersObject, getInterpolatedHeadersFactory, getInterpolatedStringFactory, getInterpolationKeys, gql, groupTransforms, hashObject, jitExecutorFactory, jsonFlatStringify, loadFromModuleExportExpression, loadYaml, mkdir, parseInterpolationStrings, parseWithCache, pathExists, printWithCache, readFile, readFileOrUrl, readUrl, resolveAdditionalResolvers, rmdirs, sanitizeNameForGraphQL, stringInterpolator, withCancel, writeFile, writeJSON };
