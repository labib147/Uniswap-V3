import { path, fs } from '@graphql-mesh/cross-helpers';
import { writeFile, flatString, AggregateError } from '@graphql-mesh/utils';
import { diff, CriticalityLevel } from '@graphql-inspector/core';
import { printSchemaWithDirectives } from '@graphql-tools/utils';
import { buildSchema } from 'graphql';

class ReadonlyStoreError extends Error {
}
class ValidationError extends Error {
}
class InMemoryStoreStorageAdapter {
    constructor() {
        this.data = new Map();
    }
    async read(key, options) {
        return this.data.get(key);
    }
    async write(key, data, options) {
        this.data.set(key, data);
    }
    async delete(key) {
        this.data.delete(key);
    }
    clear() {
        this.data.clear();
    }
}
class FsStoreStorageAdapter {
    constructor(options) {
        this.options = options;
    }
    getAbsolutePath(jsFileName) {
        return path.isAbsolute(jsFileName) ? jsFileName : path.join(this.options.cwd, jsFileName);
    }
    async read(key) {
        const absoluteModulePath = this.getAbsolutePath(key);
        try {
            return await this.options.importFn(absoluteModulePath).then(m => m.default || m);
        }
        catch (e) {
            if (e.message.startsWith('Cannot find module')) {
                return undefined;
            }
            throw e;
        }
    }
    async write(key, data, options) {
        const asString = this.options.fileType === 'ts'
            ? `// @ts-nocheck\n` + (await options.codify(data, key))
            : await options.stringify(data, key);
        const modulePath = this.getAbsolutePath(key);
        const filePath = modulePath + '.' + this.options.fileType;
        await writeFile(filePath, flatString(asString));
        await this.options.importFn(modulePath);
    }
    async delete(key) {
        const filePath = this.getAbsolutePath(key) + '.' + this.options.fileType;
        return fs.promises.unlink(filePath);
    }
}
var PredefinedProxyOptionsName;
(function (PredefinedProxyOptionsName) {
    PredefinedProxyOptionsName["JsonWithoutValidation"] = "JsonWithoutValidation";
    PredefinedProxyOptionsName["StringWithoutValidation"] = "StringWithoutValidation";
    PredefinedProxyOptionsName["GraphQLSchemaWithDiffing"] = "GraphQLSchemaWithDiffing";
})(PredefinedProxyOptionsName || (PredefinedProxyOptionsName = {}));
const escapeForTemplateLiteral = (str) => str.split('`').join('\\`').split('$').join('\\$');
const PredefinedProxyOptions = {
    JsonWithoutValidation: {
        codify: v => `export default ${JSON.stringify(v)} as any;`,
        parse: v => JSON.parse(v),
        stringify: v => JSON.stringify(v),
        validate: () => null,
    },
    StringWithoutValidation: {
        codify: v => `export default \`${escapeForTemplateLiteral(v)}\``,
        parse: v => v,
        stringify: v => v,
        validate: () => null,
    },
    GraphQLSchemaWithDiffing: {
        codify: (schema, identifier) => `
import { buildSchema, Source } from 'graphql';

const source = new Source(/* GraphQL */\`
${escapeForTemplateLiteral(printSchemaWithDirectives(schema))}
\`, \`${identifier}\`);

export default buildSchema(source, {
  assumeValid: true,
  assumeValidSDL: true
});
    `.trim(),
        parse: sdl => buildSchema(sdl),
        stringify: schema => printSchemaWithDirectives(schema),
        validate: async (oldSchema, newSchema) => {
            const changes = await diff(oldSchema, newSchema);
            const errors = [];
            for (const change of changes) {
                if (change.criticality.level === CriticalityLevel.Breaking ||
                    change.criticality.level === CriticalityLevel.Dangerous) {
                    errors.push(change.message);
                }
            }
            if (errors.length) {
                throw new AggregateError(errors);
            }
        },
    },
};
class MeshStore {
    constructor(identifier, storage, flags) {
        this.identifier = identifier;
        this.storage = storage;
        this.flags = flags;
    }
    child(childIdentifier, flags) {
        return new MeshStore(path.join(this.identifier, childIdentifier), this.storage, {
            ...this.flags,
            ...flags,
        });
    }
    proxy(id, options) {
        const path$1 = path.join(this.identifier, id);
        let value;
        let isValueCached = false;
        const ensureValueCached = async () => {
            if (!isValueCached) {
                value = await this.storage.read(path$1, options);
                isValueCached = true;
            }
        };
        const doValidation = async (newValue) => {
            await ensureValueCached();
            if (value && newValue) {
                try {
                    await options.validate(value, newValue, id);
                }
                catch (e) {
                    throw new ValidationError(`Validation failed for "${id}" under "${this.identifier}": ${e.message}`);
                }
            }
        };
        const proxy = {
            getWithSet: async (setterFn) => {
                await ensureValueCached();
                if (this.flags.validate || !value) {
                    const newValue = await setterFn();
                    if (this.flags.validate && this.flags.readonly) {
                        await doValidation(newValue);
                    }
                    if (!this.flags.readonly) {
                        await proxy.set(newValue);
                    }
                }
                return value;
            },
            get: async () => {
                await ensureValueCached();
                return value;
            },
            set: async (newValue) => {
                if (this.flags.readonly) {
                    throw new ReadonlyStoreError(`Unable to set value for "${id}" under "${this.identifier}" because the store is in read-only mode.`);
                }
                if (this.flags.validate) {
                    await doValidation(newValue);
                }
                value = newValue;
                isValueCached = true;
                await this.storage.write(path$1, value, options);
            },
            delete: () => this.storage.delete(path$1),
        };
        return proxy;
    }
}

export { FsStoreStorageAdapter, InMemoryStoreStorageAdapter, MeshStore, PredefinedProxyOptions, PredefinedProxyOptionsName, ReadonlyStoreError, ValidationError };
